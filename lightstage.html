<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Stage Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.esm.min.js",
            "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.3/build/index.module.js"
          }
        }
      </script>
    <script type="module">
        
        import * as THREE from 'three';
        import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast, MeshBVHHelper } from 'three-mesh-bvh';
        import Stats from 'three/addons/libs/stats.module.js';
        import GUI from 'lil-gui';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 3;
        }

        function setupGUI() {
            gui = new GUI({autoPlace: true, closeFolders: true});

            let gui_ls = gui.addFolder('Light Stage Setting');
            gui_ls.open();
            gui_ls.add( args.lightstage, 'ledDensity', 1, 6, 1 ).onChange(v => setupLightStage(true)).listen();
            gui_ls.add( args.lightstage, 'radius', 1, 10, 0.1).name('Light Stage Radius').onChange(v => setupLightStage(true)).listen();

            let gui_ls_lightboard = gui_ls.addFolder('Light Board');
            gui_ls_lightboard.open();
            gui_ls_lightboard.add( args.lightstage.lightboard, 'radiusWhiteLED', 0.01, 0.1, 0.01).name('White LED Radius').onChange(v => setupLightStage(true)).listen();

            let gui_ls_rig = gui_ls.addFolder('Rig');
            gui_ls_rig.open();
            gui_ls_rig.add( args.lightstage.rig, 'show').name('Show Rig').listen();

            let gui_controls = gui.addFolder('Controls');
            gui_controls.open();
            gui_controls.add( args.controls, 'autoRotateSpeed', 0, 1, 0.1).name('Rotate Speed').onChange(v => controls.autoRotateSpeed = v).listen();

            let gui_render = gui.addFolder('Render');
            gui_render.open();
            gui_render.add( args.render.rayCaster, 'count', 0, 10, 1).name('Ray Count').listen();
            gui_render.add( args.render.rayCaster, 'displayHelper').name('Display Helper').listen();
            gui_render.add( args.render.rayCaster, 'helperDepth', 1, 20, 1).name('Helper Depth').onChange(v => {
                helper.depth = v;
                if (helper.visible) helper.update();
            } ).listen();

            gui.add( args.controls, 'reset').name('Reset').onChange(v => onclick_btn_reset()).listen();
            document.body.appendChild(gui.domElement);
        }

        function setupStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }

        function buildPoints(positions, sizes, colors) {

            const vs = `
                attribute float size;
                attribute vec3 customColor;
        
                varying vec3 vColor;
        
                void main() {
        
                    vColor = customColor;
        
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        
                    gl_PointSize = size * ( 1.0 / -mvPosition.z );
        
                    gl_Position = projectionMatrix * mvPosition;
        
                }`;
        
            const fs = `
                uniform vec3 color;
                // uniform sampler2D pointTexture;
                uniform float alphaTest;
        
                varying vec3 vColor;
        
                void main() {
        
        
                    // draw circle for each point
                    if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) discard; // square -> circle
                    
                    // assign color for each point
                    gl_FragColor = vec4( vColor, 1.0 );
                    // gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        
                    // pass alpha test
                    if ( gl_FragColor.a < alphaTest ) discard;
        
                }`;
        
            // define geometry and material
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            var mat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(colors) },
                    alphaTest: { value: 0.9 }
                },
                vertexShader: vs,
                fragmentShader: fs,
            });
            var particle = new THREE.Points(geo, mat);
            return particle;
        }

        function clearScene() {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
        }

        // Function to create a snowflake-shaped light board
        function createLightBoard() {
            const lightboard = new THREE.Group();
            let leds = {
                positions: [],
                sizes: [],
                colors: [],
            }
            let radiusBasis = args.lightstage.lightboard.radiusWhiteLED;
            let radiusLED = args.lightstage.lightboard.leds.radius;

            // get the corner points of a hexagon
            const hexagonCornerVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis;
                const y = Math.sin(angle) * radiusBasis;
                hexagonCornerVertices.push({ x, y });
            }

            // place white lights on the hexagon
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonCornerVertices[i];
                const end = hexagonCornerVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;

                    if (args.render_mode === 'points') {
                        leds.positions.push(x, y, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(ledWhite)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color: ledWhite }));
                        led.position.set(x, y, 0);
                        lightboard.add(led);
                    }
                }
            }

            // place innser colored lights on the hexagon in the order of white, red, white, green, white, blue
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                if (args.render_mode === 'points') {
                    let color = i % 2 === 0 ? ledWhite : ledColors[(i - 1) / 2 % 3];
                    leds.positions.push(x, y, 0);
                    leds.sizes.push(radiusLED);
                    leds.colors.push(...(new THREE.Color(color)).toArray());
                } else {
                    const color = i % 2 === 0 ? { color: ledWhite } : { color: ledColors[(i - 1) / 2 % 3] };
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial(color));
                    led.position.set(x, y, 0);
                    lightboard.add(led);
                }
            }

            // 6 daughter boards with 4 colored lights at the end forming a diamond
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                for (let j = 0; j < 4; j++) {
                    const color = ledColors[j];
            
                    // Calculate diamond offset positions using parameterized offsetDistance
                    let offsetX = 0;
                    let offsetY = 0;
                    let dX = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetX;
                    let dY = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetY;
                    
                    if (j === 0) { offsetX = -dX; offsetY = 0; }  // j==0, red, Down
                    else if (j === 1) { offsetX = 0; offsetY = -dY; }  // j==1, Green, Left
                    else if (j === 2) { offsetX = dX; offsetY = 0; }  // j==2, Blue, Top
                    else if (j === 3) { offsetX = 0; offsetY = dY; }  // j==3, Amber, Right
            
                    const rotatedOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
                    const rotatedOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
                    
                    if (args.render_mode === 'points') {
                        leds.positions.push(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(color)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color }));
                        led.position.set(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        lightboard.add(led);
                    }
                }
            }
            
            if (args.render_mode === 'points') {
                leds = buildPoints(leds.positions, leds.sizes, leds.colors);
                lightboard.add(leds);
            }

            // draw boarder of the hexagon
            const scalar = args.lightstage.lightboard.radiusScalarBoarder;
            const hexagon = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(hexagonCornerVertices.map(v => new THREE.Vector3(scalar*v.x, scalar*v.y, 0))), new THREE.LineBasicMaterial({ color: 0xffffff }));
            lightboard.add(hexagon);

            return lightboard;
        }

        function setupLightStage(reset=false) {

            if (reset) {
                // remove all light boards and rig
                scene.remove(scene.getObjectByName('lightboards'));
                scene.remove(scene.getObjectByName('rig'));
            }

            // Generate light board positions
            let geometry = new THREE.IcosahedronGeometry(args.lightstage.radius, args.lightstage.ledDensity-1);
            const positions = [];
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                let vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
                positions.push(vertex);
            }

            // Add light boards to the scene
            var lightboards = new THREE.Group();
            lightboards.name = 'lightboards';
            positions.forEach(pos => {
                const snowflake = createLightBoard();
                snowflake.position.copy(pos);
                snowflake.lookAt(0, 0, 0);
                lightboards.add(snowflake);
            });
            scene.add(lightboards);

            // light stage rig
            var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
            var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1, transparent: true } );
            wireframe = new THREE.LineSegments( geo, mat );
            wireframe.name = 'rig';
            scene.add( wireframe );

        }

        function setupBunny() {
            // Load bunny
            const loader = new FBXLoader();
            loader.load( 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/fbx/stanford-bunny.fbx', object => {

                mesh = object.children[ 0 ];

                const geometry = mesh.geometry;
                geometry.translate( 0, 0.5 / 0.0075, 0 );
                geometry.scale( 0.1, 0.1, 0.1 );
                geometry.computeBoundsTree();
                bvh = geometry.boundsTree;

                if ( ! args.render.rayCaster.useBVH ) {

                    geometry.boundsTree = null;

                }

                scene.add( mesh );
                mesh.scale.setScalar( 0.0075 );

                helper = new MeshBVHHelper( mesh );
                helper.color.set( 0xE91E63 );
                helper.visible = args.render.rayCaster.displayHelper;
                scene.add( helper );

            } );
        }

        function setupRayCaster() {
            // raycast visualizations
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( MAX_RAYS * 2 * 3 ), 3 ) );
            lineSegments = new THREE.LineSegments( lineGeometry, new THREE.LineBasicMaterial( {
                color: RAY_COLOR,
                transparent: true,
                opacity: 0.25,
                depthWrite: false
            } ) );

            sphereInstance = new THREE.InstancedMesh(
                new THREE.SphereGeometry(),
                new THREE.MeshBasicMaterial( { color: RAY_COLOR } ),
                2 * MAX_RAYS
            );
            sphereInstance.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
            sphereInstance.count = 0;

            scene.add( sphereInstance, lineSegments );

            
            initRays();
        }

        function initRays() {

            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3( 1, 1, 1 );
            const matrix = new THREE.Matrix4();

            for ( let i = 0; i < MAX_RAYS * 2; i ++ ) {

                position.randomDirection().multiplyScalar( args.lightstage.radius * args.render.rayCaster.radiusScalar );
                matrix.compose( position, quaternion, scale );
                sphereInstance.setMatrixAt( i, matrix );

            }

        }

        function updateRays() {

            if ( ! mesh ) return;

            _raycaster.firstHitOnly = args.render.rayCaster.firstHitOnly;
            const rayCount = args.render.rayCaster.count;

            let lineNum = 0;
            for ( let i = 0; i < rayCount; i ++ ) {

                // get the current ray origin
                sphereInstance.getMatrixAt( i * 2, _matrix );
                _matrix.decompose( _position, _quaternion, _scale );

                // rotate it about the origin
                const offset = 1e-4 * window.performance.now();
                _axis.set(
                    Math.sin( i * 100 + offset ),
                    Math.cos( - i * 10 + offset ),
                    Math.sin( i * 1 + offset ),
                ).normalize();
                _position.applyAxisAngle( _axis, 0.001 );

                // update the position
                _scale.setScalar( 0.02 );
                _matrix.compose( _position, _quaternion, _scale );
                sphereInstance.setMatrixAt( i * 2, _matrix );

                // raycast
                _raycaster.ray.origin.copy( _position );
                _raycaster.ray.direction.copy( _position ).multiplyScalar( - 1 ).normalize();

                // update hits points and lines
                const hits = _raycaster.intersectObject( mesh );
                if ( hits.length !== 0 ) {

                    const hit = hits[ 0 ];
                    const point = hit.point;
                    _scale.setScalar( 0.01 );
                    _matrix.compose( point, _quaternion, _scale );
                    sphereInstance.setMatrixAt( i * 2 + 1, _matrix );

                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, point.x, point.y, point.z );

                } else {

                    sphereInstance.setMatrixAt( i * 2 + 1, _matrix );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, 0, 0, 0 );

                }

            }

            sphereInstance.count = rayCount * 2;
            sphereInstance.instanceMatrix.needsUpdate = true;

            lineSegments.geometry.setDrawRange( 0, lineNum );
            lineSegments.geometry.attributes.position.needsUpdate = true;

        }

        function setupOrbitControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = args.controls.enableDamping; // Enable inertia
            controls.dampingFactor = args.controls.dampingFactor;
            controls.autoRotate = args.controls.autoRotate;
            controls.autoRotateSpeed = args.controls.autoRotateSpeed;
        }

        // Animation loop
        function animate() {
            render();
            stats.update();
        }

        function render() {

            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();

            // updates
            if (wireframe) {
                wireframe.visible = args.lightstage.rig.show;
                // wireframe.material.opacity = (1 + Math.sin(new Date().getTime() * .0025 * args.lightstage.rig.flashSpeed)); // change opacity of the wireframe
            }
        
            if (helper) {
                helper.visible = args.render.rayCaster.displayHelper;
            }

            if (mesh) {
                mesh.rotation.y += 0.002;
                mesh.updateMatrixWorld();
            }

            if (sphereInstance) {
                updateRays();
            }
        }

        function onclick_btn_reset() {
            // copy value of args_init to args recursively
            let sync = (a, b) => {
                for (let k in a) {
                    if (typeof a[k] === 'object') {
                        sync(a[k], b[k]);
                    } else {
                        a[k] = b[k];
                    }
                }
            }
            sync(args, args_init);
    
            // reset all args recursively but not the active property
            setupLightStage(true);
            setupOrbitControls();
        }

        function onWindowResize(){

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        
        // Add the extension functions
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        // Global variables
        let scene, camera, renderer, gui, stats;
        let wireframe;
        let controls;
        let mesh, helper, bvh;
        let sphereInstance, lineSegments;

        // reusable variables
        const _raycaster = new THREE.Raycaster();
        const _position = new THREE.Vector3();
        const _quaternion = new THREE.Quaternion();
        const _scale = new THREE.Vector3( 1, 1, 1 );
        const _matrix = new THREE.Matrix4();
        const _axis = new THREE.Vector3();
        const MAX_RAYS = 3000;
        const RAY_COLOR = 0x444444;

        let render_mode = 'points';
        const args_init = {
            render_mode: render_mode,
            lightstage: {
                radius: 1.5,
                ledDensity: 1,
                lightboard: {
                    radiusWhiteLED: 0.05,
                    radiusScalarColorLED: 0.5, // the radius scalar * radiusWhiteLED is the radius of the hexogon of the color LED, which is fixed scalar due to equilateral triangle,
                    radiusScalarBoarder: 1.5, // the radius scalar * radiusWhiteLED is the radius of the hexogon of main board, fixed scalar due to equilateral triangle,
                    radiusScalarDaughter: 2.1, // the radius scalar * radiusWhiteLED is the radius of the hexogon of daughter board
                    radiusScalarDautherOffsetX: 0.3, // Parameterized offset distance towards normal direction
                    radiusScalarDautherOffsetY: 0.15,// Parameterized offset distance towards tangent direction
                    leds: {
                        radius: render_mode === 'points' ? 10 : 0.01,
                    }
                },
                rig: {
                    show: true,
                    flashSpeed: 1,  // Speed of the light stage rig flashing
                }
            },
            controls: {
                enableDamping: true,
                dampingFactor: 0.05,
                autoRotate: true,
                autoRotateSpeed: 0.1,
                reset: function() {},
            },
            render: {
                rayCaster: {
                    radiusScalar: 1.75, // the radius scalar * lightstage.radius is the radius rays
                    count: 10,
                    firstHitOnly: true,
                    useBVH: true,
                    displayHelper: false,
                    helperDepth: 10,
                }
            }
        }
        let args = JSON.parse(JSON.stringify(args_init));
        args.controls.reset = function(){};

        // Colors for the lights
        const ledWhite = 0xffffff;
        const ledColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffa500]; // Red, Green, Blue, Amber

        // Setup light stage
        init();
        setupGUI();
        setupStats();
        setupLightStage();
        setupBunny();
        setupRayCaster();
        setupOrbitControls();
        animate();

        window.addEventListener( 'resize', onWindowResize, false );
    </script>
</body>
</html>
