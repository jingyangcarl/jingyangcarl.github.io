<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Stage Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable inertia
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // Auto-rotate the camera
        controls.autoRotateSpeed = 0.5;

        // Light stage parameters
        const numLightBoards = 10;
        const radiusLightStage = 10; // Radius of the unit light stage
        const radiusLED = 0.05; // Radius of the lights
        const radiusLightBoardMainHexagonWhite = 0.5; // Radius of the white hexagon light board
        const radiusLightBoardMainHexagonColor = radiusLightBoardMainHexagonWhite - 5 * radiusLED; // Radius of the color hexagon light board
        const radiusLightBoardDaughter = 2.1 * radiusLightBoardMainHexagonWhite; // Radius of the daughter light boards
        const daughterLedOffsetDistanceNormal = 0.3 * radiusLightBoardMainHexagonWhite; // Parameterized offset distance towards normal direction
        const daughterLedOffsetDistanceTangent = 0.15 * radiusLightBoardMainHexagonWhite; // Parameterized offset distance towards tangent direction

        // Colors for the lights
        const white = 0xffffff;
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffa500]; // Red, Green, Blue, Amber

        // Function to create a snowflake-shaped light board
        function createLightBoard() {
            const lightboard = new THREE.Group();

            // get the corner points of a hexagon
            const hexagonCornerVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardMainHexagonWhite;
                const y = Math.sin(angle) * radiusLightBoardMainHexagonWhite;
                hexagonCornerVertices.push({ x, y });
            }

            // place white lights on the hexagon
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonCornerVertices[i];
                const end = hexagonCornerVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color: white }));
                    led.position.set(x, y, 0);
                    lightboard.add(led);
                }
            }

            // place innser colored lights on the hexagon in the order of white, red, white, green, white, blue
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardMainHexagonColor;
                const y = Math.sin(angle) * radiusLightBoardMainHexagonColor;
                const color = i % 2 === 0 ? { color: white } : { color: colors[(i - 1) / 2 % 3] };
                const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial(color));
                led.position.set(x, y, 0);
                lightboard.add(led);
            }

            // 6 daughter boards with 4 colored lights at the end forming a diamond
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardDaughter;
                const y = Math.sin(angle) * radiusLightBoardDaughter;
                for (let j = 0; j < 4; j++) {
                    const color = colors[j];
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color }));
            
                    // Calculate diamond offset positions using parameterized offsetDistance
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    if (j === 0) { offsetX = -daughterLedOffsetDistanceNormal; offsetY = 0; }  // j==0, red, Down
                    else if (j === 1) { offsetX = 0; offsetY = -daughterLedOffsetDistanceTangent; }  // j==1, Green, Left
                    else if (j === 2) { offsetX = daughterLedOffsetDistanceNormal; offsetY = 0; }  // j==2, Blue, Top
                    else if (j === 3) { offsetX = 0; offsetY = daughterLedOffsetDistanceTangent; }  // j==3, Amber, Right
            
                    const rotatedOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
                    const rotatedOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
                    led.position.set(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                    lightboard.add(led);
                }
            }

            return lightboard;
        }

        // Generate light board positions
        let geometry = new THREE.IcosahedronGeometry(radiusLightStage, 0);
        const positions = [];
        for (let i = 0; i < geometry.attributes.position.count; i++) {
            vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
            positions.push(vertex);
        }

        // Generate light board positions
        // const positions = [];
        // for (let i = 0; i < numLightBoards; i++) {
        //     const theta = Math.acos(1 - 2 * (i + 0.5) / numLightBoards);
        //     const phi = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
        //     const x = radius * Math.sin(theta) * Math.cos(phi);
        //     const y = radius * Math.sin(theta) * Math.sin(phi);
        //     const z = radius * Math.cos(theta);
        //     positions.push(new THREE.Vector3(x, y, z));
        // }

        // Add light boards to the scene
        positions.forEach(pos => {
            const snowflake = createLightBoard();
            snowflake.position.copy(pos);
            snowflake.lookAt(0, 0, 0);
            scene.add(snowflake);
        });

        // light stage rig
        var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
        var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
        var wireframe = new THREE.LineSegments( geo, mat );
        scene.add( wireframe );
        

        camera.position.z = 30;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();
        }
        animate();
    </script>
</body>
</html>
