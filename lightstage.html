<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Stage Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.2/dist/lil-gui.umd.js"></script>
    <script>

        function createGUI() {
            gui = new lil.GUI({autoPlace: true, closeFolders: true});

            gui.add( args, 'ledDensity', 1, 5, 1 ).onChange(v => wireframe = setupLightStage(reset=true));
            gui.add( args, 'show_rig');

            document.body.appendChild(gui.domElement);
        }

        function buildPoints(positions, sizes, colors) {

            const vs = `
                attribute float size;
                attribute vec3 customColor;
        
                varying vec3 vColor;
        
                void main() {
        
                    vColor = customColor;
        
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        
                    gl_PointSize = size * ( 1.0 / -mvPosition.z );
        
                    gl_Position = projectionMatrix * mvPosition;
        
                }`;
        
            const fs = `
                uniform vec3 color;
                // uniform sampler2D pointTexture;
                uniform float alphaTest;
        
                varying vec3 vColor;
        
                void main() {
        
        
                    // draw circle for each point
                    if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) discard; // square -> circle
                    
                    // assign color for each point
                    gl_FragColor = vec4( vColor, 1.0 );
                    // gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        
                    // pass alpha test
                    if ( gl_FragColor.a < alphaTest ) discard;
        
                }`;
        
            // define geometry and material
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            var mat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(colors) },
                    alphaTest: { value: 0.9 }
                },
                vertexShader: vs,
                fragmentShader: fs,
            });
            var particle = new THREE.Points(geo, mat);
            return particle;
        }

        function resetScene() {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
        }

        // Function to create a snowflake-shaped light board
        function createLightBoard() {
            const lightboard = new THREE.Group();
            let leds = {
                positions: [],
                sizes: [],
                colors: [],
            }

            // get the corner points of a hexagon
            const hexagonCornerVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardMainHexagonWhite;
                const y = Math.sin(angle) * radiusLightBoardMainHexagonWhite;
                hexagonCornerVertices.push({ x, y });
            }

            // place white lights on the hexagon
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonCornerVertices[i];
                const end = hexagonCornerVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;

                    if (args.render_mode === 'points') {
                        leds.positions.push(x, y, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(ledWhite)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color: ledWhite }));
                        led.position.set(x, y, 0);
                        lightboard.add(led);
                    }
                }
            }

            // place innser colored lights on the hexagon in the order of white, red, white, green, white, blue
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardMainHexagonColor;
                const y = Math.sin(angle) * radiusLightBoardMainHexagonColor;
                if (args.render_mode === 'points') {
                    let color = i % 2 === 0 ? ledWhite : ledColors[(i - 1) / 2 % 3];
                    leds.positions.push(x, y, 0);
                    leds.sizes.push(radiusLED);
                    leds.colors.push(...(new THREE.Color(color)).toArray());
                } else {
                    const color = i % 2 === 0 ? { color: ledWhite } : { color: ledColors[(i - 1) / 2 % 3] };
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial(color));
                    led.position.set(x, y, 0);
                    lightboard.add(led);
                }
            }

            // 6 daughter boards with 4 colored lights at the end forming a diamond
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusLightBoardDaughter;
                const y = Math.sin(angle) * radiusLightBoardDaughter;
                for (let j = 0; j < 4; j++) {
                    const color = ledColors[j];
            
                    // Calculate diamond offset positions using parameterized offsetDistance
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    if (j === 0) { offsetX = -daughterLedOffsetDistanceNormal; offsetY = 0; }  // j==0, red, Down
                    else if (j === 1) { offsetX = 0; offsetY = -daughterLedOffsetDistanceTangent; }  // j==1, Green, Left
                    else if (j === 2) { offsetX = daughterLedOffsetDistanceNormal; offsetY = 0; }  // j==2, Blue, Top
                    else if (j === 3) { offsetX = 0; offsetY = daughterLedOffsetDistanceTangent; }  // j==3, Amber, Right
            
                    const rotatedOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
                    const rotatedOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
                    
                    if (args.render_mode === 'points') {
                        leds.positions.push(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(color)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color }));
                        led.position.set(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        lightboard.add(led);
                    }
                }
            }
            
            if (args.render_mode === 'points') {
                leds = buildPoints(leds.positions, leds.sizes, leds.colors);
                lightboard.add(leds);
            }

            return lightboard;
        }

        function setupLightStage(reset=false) {

            if (reset) {
                resetScene();
            }

            // clear the scene
            scene.children = scene.children.filter(child => child instanceof THREE.AmbientLight);

            // Generate light board positions
            let geometry = new THREE.IcosahedronGeometry(radiusLightStage, args.ledDensity-1);
            const positions = [];
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
                positions.push(vertex);
            }

            // Add light boards to the scene
            positions.forEach(pos => {
                const snowflake = createLightBoard();
                snowflake.position.copy(pos);
                snowflake.lookAt(0, 0, 0);
                scene.add(snowflake);
            });

            // light stage rig
            var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
            var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1, transparent: true } );
            var wireframe = new THREE.LineSegments( geo, mat );
            scene.add( wireframe );

            return wireframe;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();

            // updates
            wireframe.material.opacity = args.show_rig * (1 + Math.sin(new Date().getTime() * .0025 * lightStageRigFlashSpeed)); // change opacity of the wireframe
        }

        function onWindowResize(){

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }


        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 30;

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable inertia
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // Auto-rotate the camera
        controls.autoRotateSpeed = 0.5;

        const args = {
            ledDensity: 1,
            render_mode: 'points',
            show_rig: true
        }

        // Light stage parameters
        const radiusLightStage = 10; // Radius of the unit light stage
        const radiusLED = args.render_mode === '' ? 0.05 : 50; // Radius of the lights
        const radiusLightBoardMainHexagonWhite = 0.5; // Radius of the white hexagon light board
        const radiusLightBoardMainHexagonColor = radiusLightBoardMainHexagonWhite - 0.25; // Radius of the color hexagon light board
        const radiusLightBoardDaughter = 2.1 * radiusLightBoardMainHexagonWhite; // Radius of the daughter light boards
        const daughterLedOffsetDistanceNormal = 0.3 * radiusLightBoardMainHexagonWhite; // Parameterized offset distance towards normal direction
        const daughterLedOffsetDistanceTangent = 0.15 * radiusLightBoardMainHexagonWhite; // Parameterized offset distance towards tangent direction

        // Colors for the lights
        const ledWhite = 0xffffff;
        const ledColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffa500]; // Red, Green, Blue, Amber
        const lightStageRigFlashSpeed = 1; // Speed of the light stage rig flashing

        wireframe = setupLightStage();
        createGUI();
        animate();

        window.addEventListener( 'resize', onWindowResize, false );
    </script>
</body>
</html>
