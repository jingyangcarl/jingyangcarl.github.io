<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Stage Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.2/dist/lil-gui.umd.js"></script>
    <script>

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 3;
        }

        function setupGUI() {
            gui = new lil.GUI({autoPlace: true, closeFolders: true});

            gui_ls = gui.addFolder('Light Stage Setting');
            gui_ls.open();
            gui_ls.add( args.lightstage, 'ledDensity', 1, 6, 1 ).onChange(v => setupLightStage(reset=true)).listen();
            gui_ls.add( args.lightstage, 'radius', 1, 10, 0.1).name('Light Stage Radius').onChange(v => setupLightStage(reset=true)).listen();

            gui_ls_lightboard = gui_ls.addFolder('Light Board');
            gui_ls_lightboard.open();
            gui_ls_lightboard.add( args.lightstage.lightboard, 'radiusWhiteLED', 0.01, 0.1, 0.01).name('White LED Radius').onChange(v => setupLightStage(reset=true)).listen();

            gui_ls_rig = gui_ls.addFolder('Rig');
            gui_ls_rig.open();
            gui_ls_rig.add( args.lightstage.rig, 'show').name('Show Rig').listen();

            gui_controls = gui.addFolder('Controls');
            gui_controls.open();
            gui_controls.add( args.controls, 'autoRotateSpeed', 0, 1, 0.1).name('Rotate Speed').onChange(v => controls.autoRotateSpeed = v).listen();
            gui_controls.add( args.controls, 'reset').name('Reset').onChange(v => onclick_btn_reset()).listen();

            document.body.appendChild(gui.domElement);
        }

        function buildPoints(positions, sizes, colors) {

            const vs = `
                attribute float size;
                attribute vec3 customColor;
        
                varying vec3 vColor;
        
                void main() {
        
                    vColor = customColor;
        
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        
                    gl_PointSize = size * ( 1.0 / -mvPosition.z );
        
                    gl_Position = projectionMatrix * mvPosition;
        
                }`;
        
            const fs = `
                uniform vec3 color;
                // uniform sampler2D pointTexture;
                uniform float alphaTest;
        
                varying vec3 vColor;
        
                void main() {
        
        
                    // draw circle for each point
                    if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) discard; // square -> circle
                    
                    // assign color for each point
                    gl_FragColor = vec4( vColor, 1.0 );
                    // gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        
                    // pass alpha test
                    if ( gl_FragColor.a < alphaTest ) discard;
        
                }`;
        
            // define geometry and material
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            var mat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(colors) },
                    alphaTest: { value: 0.9 }
                },
                vertexShader: vs,
                fragmentShader: fs,
            });
            var particle = new THREE.Points(geo, mat);
            return particle;
        }

        function clearScene() {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
        }

        // Function to create a snowflake-shaped light board
        function createLightBoard() {
            const lightboard = new THREE.Group();
            let leds = {
                positions: [],
                sizes: [],
                colors: [],
            }
            let radiusBasis = args.lightstage.lightboard.radiusWhiteLED;
            let radiusLED = args.lightstage.lightboard.leds.radius;

            // get the corner points of a hexagon
            const hexagonCornerVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis;
                const y = Math.sin(angle) * radiusBasis;
                hexagonCornerVertices.push({ x, y });
            }

            // place white lights on the hexagon
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonCornerVertices[i];
                const end = hexagonCornerVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;

                    if (args.render_mode === 'points') {
                        leds.positions.push(x, y, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(ledWhite)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color: ledWhite }));
                        led.position.set(x, y, 0);
                        lightboard.add(led);
                    }
                }
            }

            // place innser colored lights on the hexagon in the order of white, red, white, green, white, blue
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                if (args.render_mode === 'points') {
                    let color = i % 2 === 0 ? ledWhite : ledColors[(i - 1) / 2 % 3];
                    leds.positions.push(x, y, 0);
                    leds.sizes.push(radiusLED);
                    leds.colors.push(...(new THREE.Color(color)).toArray());
                } else {
                    const color = i % 2 === 0 ? { color: ledWhite } : { color: ledColors[(i - 1) / 2 % 3] };
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial(color));
                    led.position.set(x, y, 0);
                    lightboard.add(led);
                }
            }

            // 6 daughter boards with 4 colored lights at the end forming a diamond
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                for (let j = 0; j < 4; j++) {
                    const color = ledColors[j];
            
                    // Calculate diamond offset positions using parameterized offsetDistance
                    let offsetX = 0;
                    let offsetY = 0;
                    let dX = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetX;
                    let dY = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetY;
                    
                    if (j === 0) { offsetX = -dX; offsetY = 0; }  // j==0, red, Down
                    else if (j === 1) { offsetX = 0; offsetY = -dY; }  // j==1, Green, Left
                    else if (j === 2) { offsetX = dX; offsetY = 0; }  // j==2, Blue, Top
                    else if (j === 3) { offsetX = 0; offsetY = dY; }  // j==3, Amber, Right
            
                    const rotatedOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
                    const rotatedOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
                    
                    if (args.render_mode === 'points') {
                        leds.positions.push(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(new THREE.Color(color)).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color }));
                        led.position.set(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        lightboard.add(led);
                    }
                }
            }
            
            if (args.render_mode === 'points') {
                leds = buildPoints(leds.positions, leds.sizes, leds.colors);
                lightboard.add(leds);
            }

            // draw boarder of the hexagon
            const scalar = args.lightstage.lightboard.radiusScalarBoarder;
            const hexagon = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(hexagonCornerVertices.map(v => new THREE.Vector3(scalar*v.x, scalar*v.y, 0))), new THREE.LineBasicMaterial({ color: 0xffffff }));
            lightboard.add(hexagon);

            return lightboard;
        }

        function setupLightStage(reset=false) {

            if (reset) {
                clearScene();
            }

            // clear the scene
            scene.children = scene.children.filter(child => child instanceof THREE.AmbientLight);

            // Generate light board positions
            let geometry = new THREE.IcosahedronGeometry(args.lightstage.radius, args.lightstage.ledDensity-1);
            const positions = [];
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
                positions.push(vertex);
            }

            // Add light boards to the scene
            positions.forEach(pos => {
                const snowflake = createLightBoard();
                snowflake.position.copy(pos);
                snowflake.lookAt(0, 0, 0);
                scene.add(snowflake);
            });

            // light stage rig
            var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
            var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1, transparent: true } );
            wireframe = new THREE.LineSegments( geo, mat );
            scene.add( wireframe );

        }

        function setupControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = args.controls.enableDamping; // Enable inertia
            controls.dampingFactor = args.controls.dampingFactor;
            controls.autoRotate = args.controls.autoRotate;
            controls.autoRotateSpeed = args.controls.autoRotateSpeed;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();

            // updates
            wireframe.material.opacity = args.lightstage.rig.show * (1 + Math.sin(new Date().getTime() * .0025 * args.lightstage.rig.flashSpeed)); // change opacity of the wireframe
        }

        function onclick_btn_reset() {
            debugger;

            // copy value of args_init to args recursively
            let sync = (a, b) => {
                for (let k in a) {
                    if (typeof a[k] === 'object') {
                        sync(a[k], b[k]);
                    } else {
                        a[k] = b[k];
                    }
                }
            }
            sync(args, args_init);
    
            // reset all args recursively but not the active property
            setupLightStage(reset=true);
            setupControls();
        }

        function onWindowResize(){

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        // Global variables
        let scene, camera, renderer;
        let wireframe;
        let controls;

        let render_mode = 'points';
        const args_init = {
            render_mode: render_mode,
            lightstage: {
                radius: 1.5,
                ledDensity: 1,
                lightboard: {
                    radiusWhiteLED: 0.05,
                    radiusScalarColorLED: 0.5, // the radius factor * radiusWhiteLED is the radius of the hexogon of the color LED, which is fixed scalar due to equilateral triangle,
                    radiusScalarBoarder: 1.5, // the radius factor * radiusWhiteLED is the radius of the hexogon of main board, fixed scalar due to equilateral triangle,
                    radiusScalarDaughter: 2.1, // the radius factor * radiusWhiteLED is the radius of the hexogon of daughter board
                    radiusScalarDautherOffsetX: 0.3, // Parameterized offset distance towards normal direction
                    radiusScalarDautherOffsetY: 0.15,// Parameterized offset distance towards tangent direction
                    leds: {
                        radius: render_mode === 'points' ? 10 : 0.01,
                    }
                },
                rig: {
                    show: true,
                    flashSpeed: 1,  // Speed of the light stage rig flashing
                }
            },
            controls: {
                enableDamping: true,
                dampingFactor: 0.05,
                autoRotate: true,
                autoRotateSpeed: 0.2,
                reset: function() {},
            }
        }
        let args = JSON.parse(JSON.stringify(args_init));
        args.controls.reset = function(){};

        // Colors for the lights
        const ledWhite = 0xffffff;
        const ledColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffa500]; // Red, Green, Blue, Amber

        // Setup light stage
        init();
        setupLightStage();
        setupControls();
        setupGUI();
        animate();

        window.addEventListener( 'resize', onWindowResize, false );
    </script>
</body>
</html>
