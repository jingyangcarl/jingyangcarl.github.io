<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Stage Grid</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable inertia
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // Auto-rotate the camera
        controls.autoRotateSpeed = 0.5;

        // Light stage parameters
        const numLightBoards = 10;
        const radius = 10; // Radius of the unit sphere

        // Colors for the lights
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffa500]; // Red, Green, Blue, Amber

        // Function to create a snowflake-shaped light board
        function createSnowflake() {
            const snowflake = new THREE.Group();

            // Center hexagon of 12 white lights
            const hexagonRadius = 0.5;
            const whiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // get the corner points of a hexagon
            const hexagonVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * hexagonRadius;
                const y = Math.sin(angle) * hexagonRadius;
                hexagonVertices.push({ x, y });
            }

            // place hexagon middle edge points
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonVertices[i];
                const end = hexagonVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;
                    const whiteLED = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), whiteMaterial);
                    whiteLED.position.set(x, y, 0);
                    snowflake.add(whiteLED);
                }
            }

            // 6 branches with 4 colored lights at the end forming a diamond
            const branchLength = 1.5 * hexagonRadius;
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * branchLength;
                const y = Math.sin(angle) * branchLength;
                for (let j = 0; j < 4; j++) {
                    const color = colors[j];
                    const light = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color }));
                    const offsetAngle = angle + (j / 4) * Math.PI * 2 / 6;
                    light.position.set(x + Math.cos(offsetAngle) * 0.3, y + Math.sin(offsetAngle) * 0.3, 0);
                    snowflake.add(light);
                }
            }

            return snowflake;
        }

        // Generate light board positions
        let geometry = new THREE.IcosahedronGeometry(radius, 0);
        const positions = [];
        for (let i = 0; i < geometry.attributes.position.count; i++) {
            vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
            positions.push(vertex);
        }

        // Generate light board positions
        // const positions = [];
        // for (let i = 0; i < numLightBoards; i++) {
        //     const theta = Math.acos(1 - 2 * (i + 0.5) / numLightBoards);
        //     const phi = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
        //     const x = radius * Math.sin(theta) * Math.cos(phi);
        //     const y = radius * Math.sin(theta) * Math.sin(phi);
        //     const z = radius * Math.cos(theta);
        //     positions.push(new THREE.Vector3(x, y, z));
        // }

        // Add light boards to the scene
        positions.forEach(pos => {
            const snowflake = createSnowflake();
            snowflake.position.copy(pos);
            snowflake.lookAt(0, 0, 0);
            scene.add(snowflake);
        });

        // light stage rig
        var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
        var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
        var wireframe = new THREE.LineSegments( geo, mat );
        scene.add( wireframe );
        

        camera.position.z = 30;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();
        }
        animate();
    </script>
</body>
</html>
