<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jing Yang with Light Stage</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }
        
        a {
            color: #2983ff;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        button {
            cursor: pointer;
            text-transform: uppercase;
        }
        
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            background-color: rgba(44, 44, 44, 0.5);
            z-index: 998 !important; /* TODO Solve this in HTML */
        }
        
        a, button, input, select {
            pointer-events: auto;
        }
        
        .lil-gui {
            z-index: 999 !important; /* TODO Solve this in HTML */
        }

        /* avoid empty links */
        .icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            mask-size: contain;
            transition: background-color 0.3s;
        }
        .icon[href=""] {
            display: none;
        }

        /* Github logo */
        .github-logo {
            background-color: #525252;
            mask: url('https://cdn.jsdelivr.net/npm/simple-icons@v8/icons/github.svg') no-repeat center;
        }
        .github-logo:hover {
            background-color: #ffffff;
        }

        .home-logo {
            background-color: #5b985b;
            mask: url('https://cdn.jsdelivr.net/npm/simple-icons@v8/icons/googlehome.svg') no-repeat center;
        }
        .home-logo:hover {
            background-color: #90EE90;
        }

        .pdf-logo {
            background-color: #8a1115;
            mask: url('https://cdn.jsdelivr.net/npm/simple-icons@v8/icons/adobeacrobatreader.svg') no-repeat center;
        }
        .pdf-logo:hover {
            background-color: #EC1C24;
        }

        .arxiv-logo {
            background-color: #530d0d;
            mask: url('https://cdn.jsdelivr.net/npm/simple-icons@v8/icons/arxiv.svg') no-repeat center;
        }
        .arxiv-logo:hover {
            background-color: #B31B1B;
        }

        .youtube-logo {
            background-color: #770101;
            mask: url('https://cdn.jsdelivr.net/npm/simple-icons@v8/icons/youtube.svg') no-repeat center;
        }
        .youtube-logo:hover {
            background-color: #FF0000;
        }
        
    </style>
</head>
<body>
    <div id="info">
        <b><a href="https://jingyangcarl.com" target="_blank" rel="noopener">Jing Yang</a>'s Ph.D. Projects with <a href="https://vgl.ict.usc.edu/LightStages/" target="_blank" rel="noopener">Light Stage</a></b><br/>
        <small>Toggle other settings of the <i><a href="" target="_blank" rel="noopener">Virtual Light Stage</a></i> by <i style="color: lightgreen">Controls</i> on the right →</small>
    </div>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/nodes/Nodes.js",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.esm.min.js",
            "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.3/build/index.module.js"
          }
        }
      </script>
    <script type="module">
        
        import * as THREE from 'three';
        import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast, MeshBVHHelper } from 'three-mesh-bvh';
        import Stats from 'three/addons/libs/stats.module.js';
        import GUI from 'lil-gui';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import WebGPU from 'three/addons/capabilities/WebGPU.js';
        import WebGL from 'three/addons/capabilities/WebGL.js';
        import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
        import { color, lights, normalMap, MeshPhongNodeMaterial } from 'three/nodes';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;
            cameraObject = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                // shorten the inset camera frustum to a smaller far plane to avoid an overly long helper
            if (typeof args !== 'undefined' && args.render && args.render.camera && typeof args.render.camera.cameraFar !== 'undefined') {
                cameraObject.far = args.render.camera.cameraFar;
            } else {
                cameraObject.far = 2;
            }
            cameraObject.position.z = 0.6;
            cameraObject.updateProjectionMatrix();
            renderer = new THREE.WebGLRenderer();
            // renderer = new WebGPURenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = 0;
            labelRenderer.domElement.style.pointerEvents = 'none'; // https://stackoverflow.com/questions/71860355/css2renderer-is-not-working-with-webgl-renderer
            document.body.appendChild(labelRenderer.domElement);

            labelMaskSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            labelMaskSvg.setAttribute('id', 'labelMaskSvg');
            labelMaskSvg.setAttribute('width', String(window.innerWidth));
            labelMaskSvg.setAttribute('height', String(window.innerHeight));
            labelMaskSvg.style.position = 'absolute';
            labelMaskSvg.style.left = '0';
            labelMaskSvg.style.top = '0';
            labelMaskSvg.style.width = `${window.innerWidth}px`;
            labelMaskSvg.style.height = `${window.innerHeight}px`;
            labelMaskSvg.style.pointerEvents = 'none';
            labelMaskSvg.style.opacity = '0';

            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', 'labelMask');
            mask.setAttribute('maskUnits', 'userSpaceOnUse');

            labelMaskFullRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelMaskFullRect.setAttribute('fill', 'white');
            mask.appendChild(labelMaskFullRect);

            labelMaskInsetRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelMaskInsetRect.setAttribute('fill', 'black');
            mask.appendChild(labelMaskInsetRect);

            labelMaskSvg.appendChild(mask);
            document.body.appendChild(labelMaskSvg);

            cameraInsetLabel = document.createElement('div');
            cameraInsetLabel.id = 'cameraInsetLabel';
            cameraInsetLabel.textContent = 'Camera-space view — click handles to switch.';
            cameraInsetLabel.style.position = 'absolute';
            cameraInsetLabel.style.left = '20px';
            cameraInsetLabel.style.bottom = '0px';
            cameraInsetLabel.style.color = '#ffffff';
            cameraInsetLabel.style.fontSize = '12px';
            cameraInsetLabel.style.lineHeight = '16px';
            cameraInsetLabel.style.pointerEvents = 'none';
            document.body.appendChild(cameraInsetLabel);

            loadingLabel = document.createElement('div');
            loadingLabel.id = 'loadingLabel';
            loadingLabel.textContent = 'Loading models…';
            loadingLabel.style.position = 'absolute';
            loadingLabel.style.left = '50%';
            loadingLabel.style.top = '50%';
            loadingLabel.style.transform = 'translate(-50%, -50%)';
            loadingLabel.style.color = '#ffffff';
            loadingLabel.style.fontSize = '16px';
            loadingLabel.style.lineHeight = '20px';
            loadingLabel.style.pointerEvents = 'none';
            loadingLabel.style.display = 'none';
            document.body.appendChild(loadingLabel);
        }

        function setupGUI() {
            gui = new GUI({autoPlace: true, closeFolders: true});
            gui.close();

            let gui_ls = gui.addFolder('Light Stage Setting');
            gui_ls.open();
            gui_ls.add( args.lightstage, 'ledDensity', 1, 10, 1 ).name('Light Density').onChange(v => setupLightStage(true)).listen();
            gui_ls.add( args.lightstage, 'radius', 1, 10, 0.1).name('Light Stage Radius').onChange(v => setupLightStage(true)).listen();

            let gui_ls_lightboard = gui_ls.addFolder('Light Board');
            // gui_ls_lightboard.open();
            gui_ls_lightboard.add( args.lightstage.lightboard, 'show').name('Show Light Board').onChange(v => lightboards.visible = v).listen();
            gui_ls_lightboard.add( args.lightstage.lightboard.boundary, 'show').name('Show Boundary').onChange(v => {
                lightboards.children.forEach(lightboard => 
                    lightboard.children.forEach(x => {
                        if (x.name === 'boundary') x.visible = v;
                    }));
            }).listen();
            gui_ls_lightboard.add(args.lightstage.lightboard.leds, 'show').name('Show LEDs').onChange(v => {
                lightboards.children.forEach(lightboard => 
                    lightboard.children.forEach(x => {
                        if (x.name === 'leds') x.visible = v;
                    }));
            }).listen();
            gui_ls_lightboard.add( args.lightstage.lightboard, 'radiusWhiteLED', 0.01, 0.1, 0.01).name('Light Board Radius').onChange(v => setupLightStage(true)).listen();

            let gui_ls_rig = gui_ls.addFolder('Rig');
            // gui_ls_rig.open();
            gui_ls_rig.add( args.lightstage.rig, 'show').name('Show Rig').onChange(v => rig.visible = v).listen();
            gui_ls_rig.add( args.lightstage.rig, 'flashSpeed', 0, 5, 0.1).name('Flash Speed').listen();

            let gui_ls_patterns = gui_ls.addFolder('Patterns');
            gui_ls_patterns.open();
            const patternsActiveCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'active', ['olat', 'warmup', 'hdri', 'all', 'off']).name('Patterns').onChange(v => {
                args.lightstage.patterns.idx=0;
                if (v === 'hdri' || v === 'all') {
                    hdriDirty = true;
                    hdriLastUpdate = 0;
                } else {
                    hdriLastUpdate = 0;
                }
                if (v === 'olat') {
                    args.lightstage.patterns.olatPausedApplied = false;
                }
                if (v === 'all') {
                    allPhase = 'hdri';
                    allHdriSteps = 0;
                    args.lightstage.patterns.idx = 0;
                    hdriDirty = true;
                }
                togglePatternControls();
            }).listen();
            gui_ls_patterns.add(args.lightstage.patterns, 'fps', 1, 60, 1).name('FPS').listen();
            gui_ls_patterns.add(args.lightstage.patterns, 'idx').name('Pattern Index').listen().disable();
            const patternsAutoplayCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'autoplay').name('Auto Play').onChange(() => {
                args.lightstage.patterns.olatPausedApplied = false;
                hdriLastUpdate = 0;
            }).listen();
            const olatColorCtrl = gui_ls_patterns.addColor(args.lightstage.patterns, 'olatColor').name('OLAT Color').listen();
            const olatIntensityCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'olatIntensity', 1, 10, 0.1).name('OLAT Intensity').listen();
            const hdriPatternCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'hdriPattern', {
                Gradient: 'gradient',
                Horizon: 'horizon',
                Sunrise: 'sunrise',
                CoolSky: 'coolSky',
                Overcast: 'overcast',
                Sunset: 'sunset',
                Night: 'night',
                PurpleDusk: 'purpleDusk',
                Desert: 'desert'
            }).name('HDRI Pattern').onChange(() => { hdriDirty = true; }).listen();
            const hdriIntensityCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'hdriIntensity', 0, 5, 0.1).name('HDRI Intensity').onChange(() => { hdriDirty = true; }).listen();
            const hdriContrastCtrl = gui_ls_patterns.add(args.lightstage.patterns, 'hdriContrast', 0.1, 3, 0.1).name('HDRI Contrast').onChange(() => { hdriDirty = true; }).listen();

            function togglePatternControls() {
                const isAll = args.lightstage.patterns.active === 'all';
                const isHdri = args.lightstage.patterns.active === 'hdri';
                const isOlat = args.lightstage.patterns.active === 'olat';
                const showOlat = isOlat || args.lightstage.patterns.active === 'warmup';
                const showHdri = isHdri;
                olatColorCtrl.domElement.style.display = (!isAll && showOlat) ? '' : 'none';
                olatIntensityCtrl.domElement.style.display = (!isAll && showOlat) ? '' : 'none';
                patternsAutoplayCtrl.domElement.style.display = (isOlat || isHdri || isAll) ? '' : 'none';
                hdriPatternCtrl.domElement.style.display = (!isAll && showHdri) ? '' : 'none';
                hdriIntensityCtrl.domElement.style.display = (!isAll && showHdri) ? '' : 'none';
                hdriContrastCtrl.domElement.style.display = (!isAll && showHdri) ? '' : 'none';
            }
            togglePatternControls();

            let gui_render = gui.addFolder('Render');
            // gui_render.open();

            let gui_ls_object = gui_render.addFolder('Object');
            gui_ls_object.open();
            gui_ls_object.add( args.lightstage.object, 'type', {
                Bunny: 'bunny',
                Sphere: 'sphere',
                'Torus Knot': 'torusKnot',
                Box: 'box'
            }).name('Model').onChange(v => loadObject(v)).listen();
            gui_ls_object.add( args.lightstage.object, 'scale', 0.1, 5, 0.1 ).name('Size Scalar').onChange(v => {
                if (mesh) {
                    const baseScale = (args.lightstage.object.type === 'bunny') ? 0.01 : 0.25;
                    mesh.scale.setScalar(baseScale * v);
                }
            }).listen();

            let gui_ls_object_material = gui_ls_object.addFolder('Material');
            gui_ls_object_material.open();
            gui_ls_object_material.add( args.lightstage.object.material, 'preset', {
                Matte: 'matte',
                Metal: 'metal',
                Rubber: 'rubber',
                Glass: 'glass',
                Plastic: 'plastic',
                Jade: 'jade'
            }).name('Preset').onChange(v => {
                const preset = getMaterialPresetValues(v);
                Object.assign(args.lightstage.object.material.brdf, preset);
                applyObjectMaterial();
            }).listen();

            let gui_ls_object_brdf = gui_ls_object_material.addFolder('BRDF');
            gui_ls_object_brdf.close();
            gui_ls_object_brdf.addColor( args.lightstage.object.material.brdf, 'baseColor' ).name('Base Color').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'roughness', 0, 1, 0.01 ).name('Roughness').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'metalness', 0, 1, 0.01 ).name('Metalness').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'specularIntensity', 0, 1, 0.01 ).name('Specular Intensity').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.addColor( args.lightstage.object.material.brdf, 'specularColor' ).name('Specular Color').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'ior', 1, 2.5, 0.01 ).name('IOR').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'transmission', 0, 1, 0.01 ).name('Transmission').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'thickness', 0, 5, 0.01 ).name('Thickness').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.addColor( args.lightstage.object.material.brdf, 'attenuationColor' ).name('Attenuation Color').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'attenuationDistance', 0, 10, 0.01 ).name('Attenuation Dist').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'clearcoat', 0, 1, 0.01 ).name('Clearcoat').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'clearcoatRoughness', 0, 1, 0.01 ).name('Clearcoat Roughness').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'sheen', 0, 1, 0.01 ).name('Sheen').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.addColor( args.lightstage.object.material.brdf, 'sheenColor' ).name('Sheen Color').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'sheenRoughness', 0, 1, 0.01 ).name('Sheen Roughness').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'iridescence', 0, 1, 0.01 ).name('Iridescence').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'iridescenceIOR', 1, 2.5, 0.01 ).name('Iridescence IOR').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'iridescenceThicknessMin', 0, 1000, 1 ).name('Iridescence T Min').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'iridescenceThicknessMax', 0, 1000, 1 ).name('Iridescence T Max').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.addColor( args.lightstage.object.material.brdf, 'emissive' ).name('Emissive').onChange(() => applyObjectMaterial()).listen();
            gui_ls_object_brdf.add( args.lightstage.object.material.brdf, 'emissiveIntensity', 0, 5, 0.01 ).name('Emissive Intensity').onChange(() => applyObjectMaterial()).listen();

            let gui_ls_object_controls = gui_ls_object.addFolder('Controls');
            // gui_ls_object_controls.open();
            gui_ls_object_controls.add( args.controls, 'autoRotate_mesh').name('Mesh Auto Rotation').listen();
            gui_ls_object_controls.add( args.controls, 'autoRotate_mesh_speed', 0, 1, 0.1).name('Mesh Rotate Speed').listen();

            let gui_ls_object_bvh = gui_ls_object.addFolder('BVH');
            // gui_ls_object_bvh.open();
            gui_ls_object_bvh.add( args.render.rayCaster.rays, 'count', 0, args.render.rayCaster.rays.maxNum, 1).name('Ray Count').listen();
            gui_ls_object_bvh.add( args.render.rayCaster, 'displayHelper').name('Show BVH').listen();
            gui_ls_object_bvh.add( args.render.rayCaster, 'helperDepth', 1, 20, 1).name('BVH Depth').onChange(v => {
                helper.depth = v;
                if (helper.visible) helper.update();
            } ).listen();
            let gui_side = gui_render.addFolder('Side Renderer');
            gui_side.open();
            gui_side.add( args.render.sideRender, 'show').name('Render Selected Camera').onChange(v => {
                // keep existing behavior if rendererObject exists, otherwise just toggle flag
                if (typeof rendererObject !== 'undefined' && rendererObject && rendererObject.domElement) {
                    rendererObject.domElement.style.display = v ? 'block' : 'none';
                }
                updateLabelMask();
            }).listen();
            gui_side.add( args.render.sideRender, 'showIllumination').name('Render Illumination').listen();
            gui_side.add( args.render.sideRender, 'insetScalar', 2, 8, 1 ).name('Camera Inset Scalar').onChange(v => {
                // recompute inset sizes and update camera aspect
                insetWidth = window.innerHeight / v;
                insetHeight = window.innerHeight / v;
                if (typeof cameraObject !== 'undefined' && cameraObject) {
                    cameraObject.aspect = insetWidth / insetHeight;
                    cameraObject.updateProjectionMatrix();
                }
                updateCameraInsetLabel();
                updateLabelMask();
            }).listen();
            gui_side.add( args.render.sideRender, 'miniScalar', 2, 8, 1 ).name('Illumination Inset Scalar').listen();
            // Camera settings grouped under Side Renderer -> Camera
            let gui_camera = gui_render.addFolder('Scene Camera');
            gui_camera.open();
            gui_camera.add( args.render.camera, 'showCamera').name('Show Camera').onChange(v => {
                if (cameraHelpersArr && cameraHelpersArr.length > 0) cameraHelpersArr.forEach(h => h.visible = v);
                if (cameraMarkers) cameraMarkers.visible = v;
            }).listen();
            gui_camera.add( args.render.camera, 'cameraFar', 0.5, 10, 0.1 ).name('Camera Far').onChange(v => {
                // update inset camera far and only the selected camera view's far
                args.render.camera.cameraFar = v;
                if (typeof cameraObject !== 'undefined' && cameraObject) {
                    cameraObject.far = v;
                    cameraObject.updateProjectionMatrix();
                }
                if (cameraViews && cameraViews.length > 0) {
                    cameraViews.forEach((cv, i) => { 
                        if (i === selectedCameraIndex) cv.far = v; 
                        else cv.far = 0.001;
                        cv.updateProjectionMatrix();
                    });
                }
                if (cameraHelpersArr && cameraHelpersArr.length > 0) cameraHelpersArr.forEach(h => h.update());
            }).listen();
            gui_camera.add( args.render.camera, 'cameraCount', 1, 20, 1 ).name('Camera Count').onChange(v => {
                // recreate camera views with new count
                if (typeof createCameraViews === 'function') {
                    createCameraViews();
                    // clamp selected index
                    selectedCameraIndex = Math.min(selectedCameraIndex, cameraViews.length - 1);
                    selectCamera(selectedCameraIndex);
                }
            }).listen();
            gui_camera.add( args.render.camera, 'cameraDistance', 0.5, 2, 0.01 ).name('Camera Distance').onChange(v => {
                // recreate camera views with new distance
                if (typeof createCameraViews === 'function') {
                    createCameraViews();
                    selectCamera(selectedCameraIndex);
                }
            }).listen();

            let gui_perspective_camera = gui_render.addFolder('Perspective Camera');
            gui_perspective_camera.open();
            gui_perspective_camera.add( args.controls, 'autoRotate').name('Camera Auto Rotation').onChange(v => controls.autoRotate = v).listen();
            gui_perspective_camera.add( args.controls, 'autoRotateSpeed', 0, 1, 0.1).name('Camera Rotate Speed').onChange(v => controls.autoRotateSpeed = v).listen();

            let gui_illumination = gui_render.addFolder('Illumination');
            gui_illumination.open();
            gui_illumination.add( args.render.sideRender, 'illuminationView', { 'Selected Camera': 'selected', 'Perspective Camera': 'overall' } ).name('Illumination Coords').listen();

            let gui_projects = gui.addFolder('Projects');
            gui_projects.open();
            gui_projects.add( args.projects, 'show').name('Show Projects').onChange(v => {
                if (sphereLabels) {
                    sphereLabels.visible = v;
                    sphereLabels.children.forEach(child => child.visible = v);
                }
            }).listen();
            gui_projects.add( args.projects, 'showTitle').name('Show Title').onChange(v => {
                const infoDiv = document.getElementById('info');
                if (infoDiv) infoDiv.style.display = v ? 'block' : 'none';
            }).listen();

            gui.add( args.controls, 'reset').name('Reset').onChange(v => onclick_btn_reset()).listen();
            gui.add( args.controls, 'fullscreen').name('Fullscreen').listen();
            gui.add( args.projects, 'papercopilot').name('I also build Paper Copilot').listen();
            document.body.appendChild(gui.domElement);
        }

        function setupStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }

        function buildPoints(positions, sizes, colors) {

            const vs = `
                attribute float size;
                attribute vec3 customColor;
        
                varying vec3 vColor;
        
                void main() {
        
                    vColor = customColor;
        
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        
                    gl_PointSize = size * ( 1.0 / -mvPosition.z );
        
                    gl_Position = projectionMatrix * mvPosition;
        
                }`;
        
            const fs = `
                uniform vec3 color;
                // uniform sampler2D pointTexture;
                uniform float alphaTest;
        
                varying vec3 vColor;
        
                void main() {
        
        
                    // draw circle for each point
                    if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) discard; // square -> circle
                    
                    // assign color for each point
                    gl_FragColor = vec4( vColor, 1.0 );
                    // gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        
                    // pass alpha test
                    if ( gl_FragColor.a < alphaTest ) discard;
        
                }`;
        
            // define geometry and material
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.attributes.customColor.needsUpdate = true;
            var mat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(colors) },
                    alphaTest: { value: 0.9 }
                },
                vertexShader: vs,
                fragmentShader: fs,
            });
            var particle = new THREE.Points(geo, mat);
            return particle;
        }

        function clearScene() {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
        }

        // Function to create a snowflake-shaped light board
        function createLightBoard(ledIntensities) {
            const lightboard = new THREE.Group();
            let leds = {
                positions: [],
                sizes: [],
                colors: [],
            }
            let radiusBasis = args.lightstage.lightboard.radiusWhiteLED;
            let radiusLED = args.lightstage.lightboard.leds.radius;

            // get the corner points of a hexagon
            const hexagonCornerVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis;
                const y = Math.sin(angle) * radiusBasis;
                hexagonCornerVertices.push({ x, y });
            }

            // place white lights on the hexagon
            const midPointsPerEdge = 1;
            for (let i = 0; i < 6; i++) {
                const start = hexagonCornerVertices[i];
                const end = hexagonCornerVertices[(i + 1) % 6];
            
                // Place two points on each edge
                for (let j = 1; j <= (midPointsPerEdge + 1); j++) {
                    const t = j / (midPointsPerEdge + 1);
                    const x = start.x * (1 - t) + end.x * t;
                    const y = start.y * (1 - t) + end.y * t;

                    if (args.render_mode === 'points') {
                        leds.positions.push(x, y, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(ledIntensities[0].toArray()));
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color: ledIntensities[0] }));
                        led.position.set(x, y, 0);
                        lightboard.add(led);
                    }
                }
            }

            // place innser colored lights on the hexagon in the order of white, red, white, green, white, blue
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarColorLED;
                if (args.render_mode === 'points') {
                    let color = i % 2 === 0 ? ledIntensities[0] : ledIntensities[1+(i - 1) / 2 % 3];
                    leds.positions.push(x, y, 0);
                    leds.sizes.push(radiusLED);
                    leds.colors.push(...(color.toArray()));
                } else {
                    const color = i % 2 === 0 ? { color: ledIntensities[0] } : { color: ledIntensities[1+(i - 1) / 2 % 3] };
                    const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial(color));
                    led.position.set(x, y, 0);
                    lightboard.add(led);
                }
            }

            // 6 daughter boards with 4 colored lights at the end forming a diamond
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                const y = Math.sin(angle) * radiusBasis * args.lightstage.lightboard.radiusScalarDaughter;
                for (let j = 0; j < 4; j++) {
                    const color = ledIntensities[1+j];
            
                    // Calculate diamond offset positions using parameterized offsetDistance
                    let offsetX = 0;
                    let offsetY = 0;
                    let dX = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetX;
                    let dY = radiusBasis * args.lightstage.lightboard.radiusScalarDautherOffsetY;
                    
                    if (j === 0) { offsetX = -dX; offsetY = 0; }  // j==0, red, Down
                    else if (j === 1) { offsetX = 0; offsetY = -dY; }  // j==1, Green, Left
                    else if (j === 2) { offsetX = dX; offsetY = 0; }  // j==2, Blue, Top
                    else if (j === 3) { offsetX = 0; offsetY = dY; }  // j==3, Amber, Right
            
                    const rotatedOffsetX = offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
                    const rotatedOffsetY = offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
                    
                    if (args.render_mode === 'points') {
                        leds.positions.push(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        leds.sizes.push(radiusLED);
                        leds.colors.push(...(color).toArray());
                    } else {
                        const led = new THREE.Mesh(new THREE.SphereGeometry(radiusLED, 8, 8), new THREE.MeshBasicMaterial({ color }));
                        led.position.set(x + rotatedOffsetX, y + rotatedOffsetY, 0);
                        lightboard.add(led);
                    }
                }
            }
            
            if (args.render_mode === 'points') {
                let ledsGroup = buildPoints(leds.positions, leds.sizes, leds.colors);
                ledsGroup.visible = args.lightstage.lightboard.leds.show;
                ledsGroup.name = 'leds';

                let point_light = new THREE.PointLight(0xffffff, 1);
                point_light.name = 'led_light';
                point_light.power = 1700;
                point_light.visible = false;
                point_light.layers.enable(2); // allow illumination preview objects to be lit
                lightboard.add(point_light);
                
                lightboard.add(ledsGroup);
                lightboard.userData['leds'] = {
                    positions: leds.positions,
                    sizes: leds.sizes,
                    colors: leds.colors,
                }
            }

            // draw boarder of the hexagon
            const scalar = args.lightstage.lightboard.radiusScalarBoarder;
            const hexagon = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(hexagonCornerVertices.map(v => new THREE.Vector3(scalar*v.x, scalar*v.y, 0))), new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1, transparent: true, opacity: 0.3 }));
            hexagon.name = 'boundary';
            hexagon.visible = args.lightstage.lightboard.boundary.show;
            lightboard.add(hexagon);

            return lightboard;
        }

        function setupLightStage(reset=false) {

            if (reset) {
                // remove all light boards and rig
                scene.remove(lightboards);
                scene.remove(rig);
                args.lightstage.patterns.idx = 0 // reset pattern index
            }

            function getVertices(mesh) {
                const position = geometry.attributes.position;
                const vertices = [];
                const uniquePositions = new Set();
                
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    let vertex = new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i);
                    let vertexKey = `${vertex.x},${vertex.y},${vertex.z}`;
                    if (!uniquePositions.has(vertexKey)) {
                        uniquePositions.add(vertexKey);
                        vertices.push(vertex);
                    }
                }
               
               return vertices;
            }

            // Generate light board positions
            let geometry = new THREE.IcosahedronGeometry(args.lightstage.radius, args.lightstage.ledDensity-1);
            const positions = getVertices(geometry);

            // Convert to spherical coordinates and sort in a spiral order (theta bands with alternating phi direction)
            const spiralSort = (pts) => {
                const radius = args.lightstage.radius || 1;
                const bands = Math.max(6, args.lightstage.ledDensity * 4);
                const thetaStep = Math.PI / bands;

                const spherical = (p) => {
                    const r = Math.max(1e-6, p.length());
                    const theta = Math.acos(THREE.MathUtils.clamp(p.z / r, -1, 1)); // 0..pi
                    let phi = Math.atan2(p.y, p.x); // -pi..pi
                    if (phi < 0) phi += Math.PI * 2; // 0..2pi
                    const band = Math.round(theta / thetaStep);
                    return { theta, phi, band };
                };

                return pts.sort((a, b) => {
                    const sa = spherical(a);
                    const sb = spherical(b);
                    if (sa.band !== sb.band) return sa.band - sb.band; // from north pole to south pole
                    // keep a consistent phi direction for all bands
                    if (Math.abs(sa.phi - sb.phi) > 1e-6) return sa.phi - sb.phi;
                    return sa.theta - sb.theta;
                });
            };

            spiralSort(positions);
            

            // Add light boards to the scene
            lightboards = new THREE.Group();
            lightboards.name = 'lightboards';
            positions.forEach(pos => {
                let ledIntensities = Object.entries(args.lightstage.lightboard.leds.colors).map(([k, v]) => (new THREE.Color(v)));
                const lightboard = createLightBoard(ledIntensities);
                lightboard.name = 'lightboard';
                lightboard.visible = args.lightstage.lightboard.show;
                lightboard.position.copy(pos);
                lightboard.lookAt(0, 0, 0);
                lightboards.add(lightboard);
            });
            scene.add(lightboards);

            // light stage rig
            var geo = new THREE.EdgesGeometry( geometry ); // or rigGeometry( geometry )
            var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2, transparent: true, opacity: args.lightstage.rig.opacity} );
            rig = new THREE.LineSegments( geo, mat );
            rig.name = 'rig';
            rig.visible = args.lightstage.rig.show;
            scene.add( rig );

            if (reset && typeof setupIlluminationPreview === 'function') {
                setupIlluminationPreview();
            }

            hdriDirty = true;

        }

        function disposeCurrentMesh() {
            if (helper) {
                scene.remove(helper);
                helper = null;
            }
            if (mesh) {
                scene.remove(mesh);
                if (mesh.geometry && mesh.geometry.disposeBoundsTree) {
                    mesh.geometry.disposeBoundsTree();
                }
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) {
                    if (Array.isArray(mesh.material)) mesh.material.forEach(m => m.dispose());
                    else mesh.material.dispose();
                }
                mesh = null;
            }
            bvh = null;
        }

        function finalizeMesh(newMesh) {
            mesh = newMesh;
            scene.add(mesh);

            if (args && args.lightstage && args.lightstage.object && typeof args.lightstage.object.scale === 'number') {
                const baseScale = (args.lightstage.object.type === 'bunny') ? 0.01 : 0.25;
                mesh.scale.setScalar(baseScale * args.lightstage.object.scale);
            }

            const geometry = mesh.geometry;
            geometry.computeBoundsTree();
            bvh = geometry.boundsTree;

            if ( ! args.render.rayCaster.useBVH ) {
                geometry.boundsTree = null;
            }

            // compute object center (bounding box center) for camera targets
            const bbox = new THREE.Box3().setFromObject(mesh);
            bbox.getCenter(objectTarget);

            helper = new MeshBVHHelper( mesh );
            helper.color.set( 'lightgreen' );
            helper.visible = args.render.rayCaster.displayHelper;
            scene.add( helper );

            // recreate camera views now that we know the object target
            if (typeof createCameraViews === 'function') {
                createCameraViews();
                selectCamera(selectedCameraIndex);
            }

            applyObjectMaterial();
        }

        function getMaterialPresetValues(preset) {
            switch (preset) {
                case 'glass':
                    return {
                        baseColor: 0xffffff,
                        roughness: 0.02,
                        metalness: 0.0,
                        specularIntensity: 1.0,
                        specularColor: 0xffffff,
                        ior: 1.5,
                        transmission: 1.0,
                        thickness: 0.8,
                        attenuationColor: 0xffffff,
                        attenuationDistance: 2.0,
                        clearcoat: 0.0,
                        clearcoatRoughness: 0.0,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
                case 'plastic':
                    return {
                        baseColor: 0x1e3a8a,
                        roughness: 0.15,
                        metalness: 0.0,
                        specularIntensity: 0.8,
                        specularColor: 0xffffff,
                        ior: 1.5,
                        transmission: 0.0,
                        thickness: 0.0,
                        attenuationColor: 0xffffff,
                        attenuationDistance: 0.0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.02,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
                case 'rubber':
                    return {
                        baseColor: 0x222222,
                        roughness: 0.9,
                        metalness: 0.0,
                        specularIntensity: 0.1,
                        specularColor: 0xffffff,
                        ior: 1.5,
                        transmission: 0.0,
                        thickness: 0.0,
                        attenuationColor: 0xffffff,
                        attenuationDistance: 0.0,
                        clearcoat: 0.0,
                        clearcoatRoughness: 0.0,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
                case 'jade':
                    return {
                        baseColor: 0x6bbf87,
                        roughness: 0.6,
                        metalness: 0.0,
                        specularIntensity: 0.2,
                        specularColor: 0xffffff,
                        ior: 1.4,
                        transmission: 0.35,
                        thickness: 1.2,
                        attenuationColor: 0x2f6b3a,
                        attenuationDistance: 1.5,
                        clearcoat: 0.0,
                        clearcoatRoughness: 0.0,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
                case 'metal':
                    return {
                        baseColor: 0xffffff,
                        roughness: 0.2,
                        metalness: 1.0,
                        specularIntensity: 1.0,
                        specularColor: 0xffffff,
                        ior: 1.5,
                        transmission: 0.0,
                        thickness: 0.0,
                        attenuationColor: 0xffffff,
                        attenuationDistance: 0.0,
                        clearcoat: 0.0,
                        clearcoatRoughness: 0.0,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
                case 'matte':
                default:
                    return {
                        baseColor: 0xffffff,
                        roughness: 0.9,
                        metalness: 0.0,
                        specularIntensity: 0.1,
                        specularColor: 0xffffff,
                        ior: 1.5,
                        transmission: 0.0,
                        thickness: 0.0,
                        attenuationColor: 0xffffff,
                        attenuationDistance: 0.0,
                        clearcoat: 0.0,
                        clearcoatRoughness: 0.0,
                        sheen: 0.0,
                        sheenColor: 0xffffff,
                        sheenRoughness: 0.5,
                        iridescence: 0.0,
                        iridescenceIOR: 1.3,
                        iridescenceThicknessMin: 100,
                        iridescenceThicknessMax: 400,
                        emissive: 0x000000,
                        emissiveIntensity: 0.0,
                    };
            }
        }

        function applyObjectMaterial() {
            if (!mesh || !args || !args.lightstage || !args.lightstage.object || !args.lightstage.object.material) return;
            const brdf = args.lightstage.object.material.brdf;
            const applyToMesh = (m) => {
                let mat = m.material;
                if (Array.isArray(mat)) {
                    mat = mat.map(() => new THREE.MeshPhysicalMaterial({
                        color: brdf.baseColor,
                        roughness: brdf.roughness,
                        metalness: brdf.metalness,
                        specularIntensity: brdf.specularIntensity,
                        specularColor: brdf.specularColor,
                        ior: brdf.ior,
                        transmission: brdf.transmission,
                        thickness: brdf.thickness,
                        attenuationColor: brdf.attenuationColor,
                        attenuationDistance: brdf.attenuationDistance,
                        clearcoat: brdf.clearcoat,
                        clearcoatRoughness: brdf.clearcoatRoughness,
                        sheen: brdf.sheen,
                        sheenColor: brdf.sheenColor,
                        sheenRoughness: brdf.sheenRoughness,
                        iridescence: brdf.iridescence,
                        iridescenceIOR: brdf.iridescenceIOR,
                        iridescenceThicknessRange: [brdf.iridescenceThicknessMin, brdf.iridescenceThicknessMax],
                        emissive: brdf.emissive,
                        emissiveIntensity: brdf.emissiveIntensity,
                    }));
                    mat.forEach(matItem => { matItem.needsUpdate = true; });
                    m.material = mat;
                    return;
                }
                if (!(mat instanceof THREE.MeshPhysicalMaterial)) {
                    mat = new THREE.MeshPhysicalMaterial();
                } else {
                    mat.color.set(brdf.baseColor);
                    mat.roughness = brdf.roughness;
                    mat.metalness = brdf.metalness;
                    mat.specularIntensity = brdf.specularIntensity;
                    mat.specularColor.set(brdf.specularColor);
                    mat.ior = brdf.ior;
                    mat.transmission = brdf.transmission;
                    mat.thickness = brdf.thickness;
                    mat.attenuationColor.set(brdf.attenuationColor);
                    mat.attenuationDistance = brdf.attenuationDistance;
                    mat.clearcoat = brdf.clearcoat;
                    mat.clearcoatRoughness = brdf.clearcoatRoughness;
                    mat.sheen = brdf.sheen;
                    mat.sheenColor.set(brdf.sheenColor);
                    mat.sheenRoughness = brdf.sheenRoughness;
                    mat.iridescence = brdf.iridescence;
                    mat.iridescenceIOR = brdf.iridescenceIOR;
                    mat.iridescenceThicknessRange = [brdf.iridescenceThicknessMin, brdf.iridescenceThicknessMax];
                    mat.emissive.set(brdf.emissive);
                    mat.emissiveIntensity = brdf.emissiveIntensity;
                }
                mat.color.set(brdf.baseColor);
                mat.roughness = brdf.roughness;
                mat.metalness = brdf.metalness;
                mat.specularIntensity = brdf.specularIntensity;
                mat.specularColor.set(brdf.specularColor);
                mat.ior = brdf.ior;
                mat.transmission = brdf.transmission;
                mat.thickness = brdf.thickness;
                mat.attenuationColor.set(brdf.attenuationColor);
                mat.attenuationDistance = brdf.attenuationDistance;
                mat.clearcoat = brdf.clearcoat;
                mat.clearcoatRoughness = brdf.clearcoatRoughness;
                mat.sheen = brdf.sheen;
                mat.sheenColor.set(brdf.sheenColor);
                mat.sheenRoughness = brdf.sheenRoughness;
                mat.iridescence = brdf.iridescence;
                mat.iridescenceIOR = brdf.iridescenceIOR;
                mat.iridescenceThicknessRange = [brdf.iridescenceThicknessMin, brdf.iridescenceThicknessMax];
                mat.emissive.set(brdf.emissive);
                mat.emissiveIntensity = brdf.emissiveIntensity;
                m.material = mat;
                mat.needsUpdate = true;
            };

            if (mesh.isMesh) {
                applyToMesh(mesh);
            }
            mesh.traverse((child) => {
                if (child.isMesh) applyToMesh(child);
            });
        }

        function generateGradientHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const sky = { r: 0.25, g: 0.45, b: 0.9 };
                    const ground = { r: 0.9, g: 0.6, b: 0.25 };
                    const t = v;
                    let r = sky.r * (1 - t) + ground.r * t;
                    let g = sky.g * (1 - t) + ground.g * t;
                    let b = sky.b * (1 - t) + ground.b * t;
                    const hue = Math.sin(u * Math.PI * 2) * 0.08;
                    r = Math.min(1, Math.max(0, r + hue));
                    b = Math.min(1, Math.max(0, b - hue));
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateHorizonHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                const sky = { r: 0.15, g: 0.25, b: 0.6 };
                const ground = { r: 0.35, g: 0.25, b: 0.15 };
                const horizon = Math.exp(-Math.pow((v - 0.55) * 10.0, 2));
                for (let x = 0; x < width; x++) {
                    const t = v;
                    let r = sky.r * (1 - t) + ground.r * t;
                    let g = sky.g * (1 - t) + ground.g * t;
                    let b = sky.b * (1 - t) + ground.b * t;
                    r = Math.min(1, r + horizon * 0.35);
                    g = Math.min(1, g + horizon * 0.35);
                    b = Math.min(1, b + horizon * 0.25);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateSunriseHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const sun = Math.exp(-Math.pow((u - 0.5) * 8.0, 2)) * Math.exp(-Math.pow((v - 0.55) * 10.0, 2));
                    let r = 0.1 + 0.8 * sun + 0.6 * (1 - v);
                    let g = 0.1 + 0.4 * sun + 0.3 * (1 - v);
                    let b = 0.2 + 0.1 * sun + 0.4 * v;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateCoolSkyHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const band = 0.5 + 0.5 * Math.sin(u * Math.PI * 4) * Math.exp(-Math.pow((v - 0.3) * 8.0, 2));
                    let r = 0.15 + 0.2 * (1 - v) + 0.05 * band;
                    let g = 0.2 + 0.3 * (1 - v) + 0.08 * band;
                    let b = 0.5 + 0.4 * (1 - v) + 0.2 * band;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateOvercastHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                const sky = 0.7 + 0.2 * (1 - v);
                for (let x = 0; x < width; x++) {
                    const fog = 0.02 * Math.sin((x / width) * Math.PI * 6);
                    const val = Math.min(1, Math.max(0, sky + fog));
                    const idx = (y * width + x) * 3;
                    colors[idx] = val;
                    colors[idx + 1] = val;
                    colors[idx + 2] = val;
                }
            }
            return { width, height, colors };
        }

        function generateSunsetHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const sun = Math.exp(-Math.pow((u - 0.75) * 10.0, 2)) * Math.exp(-Math.pow((v - 0.55) * 12.0, 2));
                    let r = 0.15 + 0.8 * (1 - v) + 0.6 * sun;
                    let g = 0.1 + 0.4 * (1 - v) + 0.2 * sun;
                    let b = 0.2 + 0.1 * (1 - v) + 0.05 * sun;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateNightHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const moon = Math.exp(-Math.pow((u - 0.3) * 14.0, 2)) * Math.exp(-Math.pow((v - 0.65) * 14.0, 2));
                    let r = 0.02 + 0.05 * moon;
                    let g = 0.03 + 0.08 * moon;
                    let b = 0.06 + 0.2 * moon + 0.1 * v;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generatePurpleDuskHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const glow = Math.exp(-Math.pow((u - 0.6) * 9.0, 2)) * Math.exp(-Math.pow((v - 0.5) * 9.0, 2));
                    let r = 0.2 + 0.4 * glow + 0.2 * (1 - v);
                    let g = 0.1 + 0.2 * glow + 0.1 * (1 - v);
                    let b = 0.3 + 0.4 * glow + 0.3 * v;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function generateDesertHDRI(width, height) {
            const colors = new Float32Array(width * height * 3);
            for (let y = 0; y < height; y++) {
                const v = y / (height - 1);
                for (let x = 0; x < width; x++) {
                    const u = x / (width - 1);
                    const sun = Math.exp(-Math.pow((u - 0.5) * 10.0, 2)) * Math.exp(-Math.pow((v - 0.7) * 10.0, 2));
                    let r = 0.3 + 0.6 * sun + 0.4 * (1 - v);
                    let g = 0.25 + 0.4 * sun + 0.3 * (1 - v);
                    let b = 0.15 + 0.2 * sun + 0.2 * v;
                    r = Math.min(1, r);
                    g = Math.min(1, g);
                    b = Math.min(1, b);
                    const idx = (y * width + x) * 3;
                    colors[idx] = r;
                    colors[idx + 1] = g;
                    colors[idx + 2] = b;
                }
            }
            return { width, height, colors };
        }

        function applyHDRIPattern() {
            if (!lightboards || lightboards.children.length === 0) return;
            const off = 0.1;
            const width = args.lightstage.patterns.hdriResolution || 128;
            const height = Math.floor(width / 2);
            const pattern = args.lightstage.patterns.hdriPattern || 'gradient';
            if (!hdriCache || hdriCache.width !== width || hdriCache.height !== height || hdriCache.pattern !== pattern) {
                if (pattern === 'horizon') hdriCache = generateHorizonHDRI(width, height);
                else if (pattern === 'sunrise') hdriCache = generateSunriseHDRI(width, height);
                else if (pattern === 'coolSky') hdriCache = generateCoolSkyHDRI(width, height);
                else if (pattern === 'overcast') hdriCache = generateOvercastHDRI(width, height);
                else if (pattern === 'sunset') hdriCache = generateSunsetHDRI(width, height);
                else if (pattern === 'night') hdriCache = generateNightHDRI(width, height);
                else if (pattern === 'purpleDusk') hdriCache = generatePurpleDuskHDRI(width, height);
                else if (pattern === 'desert') hdriCache = generateDesertHDRI(width, height);
                else hdriCache = generateGradientHDRI(width, height);
                hdriCache.pattern = pattern;
            }

            const lightDirs = lightboards.children.map(lb => lb.position.clone().normalize());
            const sums = new Float32Array(lightDirs.length * 3);
            const counts = new Uint32Array(lightDirs.length);

            for (let y = 0; y < height; y++) {
                const v = (y + 0.5) / height;
                const theta = v * Math.PI;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                for (let x = 0; x < width; x++) {
                    const u = (x + 0.5) / width;
                    const phi = u * Math.PI * 2;
                    const dirX = sinTheta * Math.cos(phi);
                    const dirY = sinTheta * Math.sin(phi);
                    const dirZ = cosTheta;

                    let bestIdx = 0;
                    let bestDot = -1e9;
                    for (let i = 0; i < lightDirs.length; i++) {
                        const d = lightDirs[i];
                        const dot = d.x * dirX + d.y * dirY + d.z * dirZ;
                        if (dot > bestDot) {
                            bestDot = dot;
                            bestIdx = i;
                        }
                    }

                    const idx = (y * width + x) * 3;
                    sums[bestIdx * 3] += hdriCache.colors[idx];
                    sums[bestIdx * 3 + 1] += hdriCache.colors[idx + 1];
                    sums[bestIdx * 3 + 2] += hdriCache.colors[idx + 2];
                    counts[bestIdx] += 1;
                }
            }

            const intensity = Math.max(0.0, args.lightstage.patterns.hdriIntensity || 1.0);
            const contrast = Math.max(0.01, args.lightstage.patterns.hdriContrast || 1.0);
            if (!hdriBoardColors || hdriBoardColors.length !== lightboards.children.length * 3) {
                hdriBoardColors = new Float32Array(lightboards.children.length * 3);
            }
            lightboards.children.forEach((lightboard, i) => {
                const leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                const leds_init = lightboard.userData['leds'].colors;
                const led_light = lightboard.getObjectByName('led_light');

                const count = counts[i] || 1;
                let r = Math.min(1, sums[i * 3] / count);
                let g = Math.min(1, sums[i * 3 + 1] / count);
                let b = Math.min(1, sums[i * 3 + 2] / count);
                r = Math.min(1, Math.max(0, Math.pow(r, 1 / contrast)));
                g = Math.min(1, Math.max(0, Math.pow(g, 1 / contrast)));
                b = Math.min(1, Math.max(0, Math.pow(b, 1 / contrast)));

                hdriBoardColors[i * 3] = r;
                hdriBoardColors[i * 3 + 1] = g;
                hdriBoardColors[i * 3 + 2] = b;

                for (let j = 0; j < leds.count; j++) {
                    const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                    if (isWhite) {
                        leds.setXYZ(j, intensity * r, intensity * g, intensity * b);
                    } else {
                        leds.setXYZ(j, off * leds_init[3*j], off * leds_init[3*j+1], off * leds_init[3*j+2]);
                    }
                }

                if (led_light) {
                    led_light.visible = true;
                    led_light.color.setRGB(r, g, b);
                    led_light.intensity = intensity;
                }
                leds.needsUpdate = true;
            });
        }

        function createPrimitiveMesh(type) {
            let geometry;
            switch (type) {
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.4, 64, 64);
                    break;
                case 'torusKnot':
                    geometry = new THREE.TorusKnotGeometry(0.25, 0.08, 200, 32);
                    break;
                case 'box':
                default:
                    geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                    break;
            }
            const material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.5, metalness: 0.0 });
            const primitive = new THREE.Mesh(geometry, material);
            primitive.position.set(0, 0, 0);
            return primitive;
        }

        function setupBunny() {
            // Load bunny
            const loader = new FBXLoader();
            setLoadingVisible(true);
            loader.load( 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/fbx/stanford-bunny.fbx', object => {

                const bunny = object.children[ 0 ];
                const geometry = bunny.geometry;
                geometry.translate( 0, 0.5 / 0.0075, 0 );
                geometry.scale( 0.1, 0.1, 0.1 );
                bunny.scale.setScalar( 0.0075 );
                finalizeMesh(bunny);
                setLoadingVisible(false);

            }, undefined, () => {
                setLoadingVisible(false);
            } );
        }

        function loadObject(type) {
            disposeCurrentMesh();
            if (type === 'bunny') {
                setupBunny();
                return;
            }
            const primitive = createPrimitiveMesh(type);
            finalizeMesh(primitive);
            setLoadingVisible(false);
        }

        function setupIlluminationPreview() {
            illuminationSceneGrey = new THREE.Scene();
            illuminationSceneChrome = new THREE.Scene();

            const geom = new THREE.SphereGeometry(0.08, 32, 32);
            const greyMat = new THREE.MeshStandardMaterial({
                color: 0xb0b0b0,
                metalness: 0.0,
                roughness: 1.0,
            });
            const chromeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.0,
            });

            greyBall = new THREE.Mesh(geom, greyMat);
            chromeBall = new THREE.Mesh(geom, chromeMat);
            greyBall.position.set(0, 0, 0);
            chromeBall.position.set(0, 0, 0);

            illuminationSceneGrey.add(greyBall);
            illuminationSceneChrome.add(chromeBall);

            illuminationCameraGrey = new THREE.PerspectiveCamera(20, 1, 0.1, 10);
            illuminationCameraChrome = new THREE.PerspectiveCamera(20, 1, 0.1, 10);
            illuminationCameraGrey.position.set(0, 0.25, 0.6);
            illuminationCameraChrome.position.set(0, 0.25, 0.6);
            illuminationCameraGrey.lookAt(0, 0, 0);
            illuminationCameraChrome.lookAt(0, 0, 0);

            illuminationLightsGrey = [];
            illuminationLightsChrome = [];
            if (lightboards && lightboards.children && lightboards.children.length > 0) {
                lightboards.children.forEach((lightboard) => {
                    const srcLight = lightboard.getObjectByName('led_light');
                    if (!srcLight) {
                        illuminationLightsGrey.push(null);
                        illuminationLightsChrome.push(null);
                        return;
                    }
                    const lightGrey = new THREE.PointLight(srcLight.color.clone(), srcLight.intensity);
                    lightGrey.power = srcLight.power;
                    lightGrey.visible = srcLight.visible;
                    srcLight.getWorldPosition(_illuminationLightPos);
                    lightGrey.position.copy(_illuminationLightPos);

                    const lightChrome = new THREE.PointLight(srcLight.color.clone(), srcLight.intensity);
                    lightChrome.power = srcLight.power;
                    lightChrome.visible = srcLight.visible;
                    lightChrome.position.copy(_illuminationLightPos);

                    illuminationSceneGrey.add(lightGrey);
                    illuminationSceneChrome.add(lightChrome);
                    illuminationLightsGrey.push(lightGrey);
                    illuminationLightsChrome.push(lightChrome);
                });
            }
        }

        function setupRayCaster() {
            // raycast visualizations
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( args.render.rayCaster.rays.maxNum * 2 * 3 ), 3 ) );
            lineSegments = new THREE.LineSegments( lineGeometry, new THREE.LineBasicMaterial( {
                color: args.render.rayCaster.rays.color,
                transparent: true,
                opacity: 0.25,
                depthWrite: false
            } ) );

            sphereInstance = new THREE.InstancedMesh(
                new THREE.SphereGeometry(),
                new THREE.MeshBasicMaterial( { color: args.render.rayCaster.rays.color } ),
                2 * args.render.rayCaster.rays.maxNum
            );
            sphereInstance.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
            sphereInstance.count = 0;

            scene.add( sphereInstance, lineSegments );
            
            initRays();
            initLabels();
        }

        function initLabels() {

            // add labels
            sphereLabels = new THREE.Group();
            for (let i = 0; i < args.projects.items.length; i++) {

                let project = args.projects.items[i];
                var div = document.createElement('div');
                div.innerHTML = `<i>${project.conf}<i><br><i><b>${project.name}</b><i><br> \
                    <a class="icon home-logo" href="${project.page}" target="_blank"></a> \
                    <a class="icon github-logo" href="${project.github}" target="_blank"></a> \
                    <a class="icon pdf-logo" href="${project.pdf}" target="_blank"></a> \
                    <a class="icon arxiv-logo" href="${project.arxiv}" target="_blank"></a> \
                    <a class="icon youtube-logo" href="${project.youtube}" target="_blank"></a>`;
                div.style.color = 'white';
                var label = new CSS2DObject(div);
                label.visible = args.projects.show;
                sphereLabels.add(label);
            }

            sphereLabels.visible = args.projects.show;
            scene.add( sphereLabels );
        }

        function initRays() {

            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3( 1, 1, 1 );
            const matrix = new THREE.Matrix4();

            for ( let i = 0; i < args.render.rayCaster.rays.maxNum * 2; i ++ ) {

                position.randomDirection().multiplyScalar( args.lightstage.radius * args.render.rayCaster.radiusScalar );
                matrix.compose( position, quaternion, scale );
                sphereInstance.setMatrixAt( i, matrix );

            }

        }

        function updateRays() {

            if ( ! mesh ) return;

            _raycaster.firstHitOnly = args.render.rayCaster.firstHitOnly;
            const rayCount = args.render.rayCaster.rays.count;

            let lineNum = 0;
            for ( let i = 0; i < rayCount; i ++ ) {

                // get the current ray origin
                sphereInstance.getMatrixAt( i * 2, _matrix );
                _matrix.decompose( _position, _quaternion, _scale );

                // rotate it about the origin
                const offset = 1e-5 * window.performance.now();
                _axis.set(
                    Math.sin( i * 100 + offset ),
                    Math.cos( - i * 10 + offset ),
                    Math.sin( i * 1 + offset ),
                ).normalize();
                _position.applyAxisAngle( _axis, 0.0003 );

                // update the position
                _scale.setScalar( args.render.rayCaster.rays.sphereScale );
                _matrix.compose( _position, _quaternion, _scale );
                sphereInstance.setMatrixAt( i * 2, _matrix );

                // update label position
                if (i < sphereLabels.children.length) {
                    sphereLabels.children[i].visible = args.projects.show;
                    sphereLabels.children[i].position.copy(_position);
                }

                // raycast
                _raycaster.ray.origin.copy( _position );
                _raycaster.ray.direction.copy( _position ).multiplyScalar( - 1 ).normalize();

                // update hits points and lines
                const hits = _raycaster.intersectObject( mesh );
                if ( hits.length !== 0 ) {

                    const hit = hits[ 0 ];
                    const point = hit.point;
                    _scale.setScalar( 0.01 );
                    _matrix.compose( point, _quaternion, _scale );
                    sphereInstance.setMatrixAt( i * 2 + 1, _matrix );

                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, point.x, point.y, point.z );

                } else {

                    sphereInstance.setMatrixAt( i * 2 + 1, _matrix );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, _position.x, _position.y, _position.z );
                    lineSegments.geometry.attributes.position.setXYZ( lineNum ++, 0, 0, 0 );

                }

            }

            sphereInstance.count = rayCount * 2;
            sphereInstance.instanceMatrix.needsUpdate = true;

            lineSegments.geometry.setDrawRange( 0, lineNum );
            lineSegments.geometry.attributes.position.needsUpdate = true;

        }

        function updatePattern() {
            let off = 0.1;
            let curr = new Date().getTime();
            if (args.lightstage.patterns.active === 'olat') {
                _olatColor.set(args.lightstage.patterns.olatColor || 0xffffff);
                const olatIntensity = (typeof args.lightstage.patterns.olatIntensity === 'number') ? args.lightstage.patterns.olatIntensity : 1.0;
                const olatAutoplay = args.lightstage.patterns.autoplay === true;
                if (olatAutoplay && args.lightstage.patterns.olatPausedApplied) {
                    args.lightstage.patterns.olatPausedApplied = false;
                }
                const olatInterval = 1000 / args.lightstage.patterns.fps;
                const shouldStep = olatAutoplay
                    ? (curr - args.lightstage.patterns.last_update > olatInterval)
                    : (!args.lightstage.patterns.olatPausedApplied);
                
                // reset all lights to off
                if (args.lightstage.patterns.idx == 0) {
                    lightboards.children.forEach((lightboard, i) => {
                        let leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                        let leds_init = lightboard.userData['leds'].colors;
                        for (let j = 0; j < leds.count; j++) {
                            leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                        }
                        leds.needsUpdate = true;
                    });
                }

                if (shouldStep) {
                    args.lightstage.patterns.last_update = curr;

                    let n_all_white = args.lightstage.patterns.fps; // 1 second all white
                    let n_all_off = args.lightstage.patterns.fps / 2; // 0.5 second all off
                    
                    // update lights
                    lightboards.children.forEach((lightboard, i) => {
                        let leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                        let leds_init = lightboard.userData['leds'].colors;
                        const isOlatBoard = (i + (n_all_white + n_all_off) == args.lightstage.patterns.idx);
                        if (!isOlatBoard) {
                            _whiteColor.setRGB(leds_init[0], leds_init[1], leds_init[2]);
                        }
                        let led_light = lightboard.getObjectByName('led_light');
                        if (args.lightstage.patterns.idx < n_all_white) {
                            // swith on all
                            for (let j = 0; j < leds.count; j++) {
                                leds.setXYZ(j, leds_init[3*j], leds_init[3*j+1], leds_init[3*j+2]);
                                led_light.visible = true;
                            }
                        } else if (args.lightstage.patterns.idx < (n_all_white + n_all_off)) {
                            // switch off all
                            for (let j = 0; j < leds.count; j++) {
                                leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                led_light.visible = false;
                            }
                        } else {
                            // olat pattern

                            // switch on the current light board i
                            if (i+(n_all_white + n_all_off) == args.lightstage.patterns.idx) {
                                for (let j = 0; j < leds.count; j++) {
                                    const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                                    if (isWhite) {
                                        leds.setXYZ(j, olatIntensity * _olatColor.r, olatIntensity * _olatColor.g, olatIntensity * _olatColor.b);
                                        led_light.visible = true;
                                    } else {
                                        leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                    }
                                }
                            } else {
                                // switch all other white LEDs off
                                for (let j = 0; j < leds.count; j++) {
                                    const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                                    if (isWhite) {
                                        leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                        led_light.visible = false;
                                    }
                                }
                            }
                            
                        }
                        if (led_light) {
                            if (args.lightstage.patterns.idx >= (n_all_white + n_all_off)) {
                                if (isOlatBoard) {
                                    led_light.color.copy(_olatColor);
                                    led_light.intensity = Math.max(0.0, olatIntensity);
                                }
                            }
                        }
                        leds.needsUpdate = true;
                    });
                    if (olatAutoplay) {
                        args.lightstage.patterns.idx = (args.lightstage.patterns.idx+1) % (lightboards.children.length+(n_all_white + n_all_off));
                    } else {
                        args.lightstage.patterns.olatPausedApplied = true;
                    }
                }
            } else if (args.lightstage.patterns.active === 'hdri') {
                const hdriAutoplay = args.lightstage.patterns.autoplay === true;
                if (hdriAutoplay) {
                    const hdriAutoFps = Math.max(0.1, (args.lightstage.patterns.fps || 1) * 0.1);
                    const hdriInterval = 1000 / hdriAutoFps;
                    if (!hdriLastUpdate) hdriLastUpdate = curr;
                    if (curr - hdriLastUpdate > hdriInterval) {
                        hdriLastUpdate = curr;
                        const currentPattern = args.lightstage.patterns.hdriPattern || hdriPatternSequence[0];
                        let patternIndex = hdriPatternSequence.indexOf(currentPattern);
                        if (patternIndex < 0) patternIndex = 0;
                        patternIndex = (patternIndex + 1) % hdriPatternSequence.length;
                        args.lightstage.patterns.hdriPattern = hdriPatternSequence[patternIndex];
                        hdriDirty = true;
                    }
                }
                if (args.lightstage.patterns.idx >= 0 || hdriDirty) {
                    applyHDRIPattern();
                    args.lightstage.patterns.idx = -1;
                    hdriDirty = false;
                }
            } else if (args.lightstage.patterns.active === 'all') {
                if (allPhase === 'hdri') {
                    const hdriAutoplay = args.lightstage.patterns.autoplay === true;
                    if (hdriAutoplay) {
                        const hdriAutoFps = Math.max(0.1, (args.lightstage.patterns.fps || 1) * 0.1);
                        const hdriInterval = 1000 / hdriAutoFps;
                        if (!hdriLastUpdate) hdriLastUpdate = curr;
                        if (curr - hdriLastUpdate > hdriInterval) {
                            hdriLastUpdate = curr;
                            const currentPattern = args.lightstage.patterns.hdriPattern || hdriPatternSequence[0];
                            let patternIndex = hdriPatternSequence.indexOf(currentPattern);
                            if (patternIndex < 0) patternIndex = 0;
                            patternIndex = (patternIndex + 1) % hdriPatternSequence.length;
                            args.lightstage.patterns.hdriPattern = hdriPatternSequence[patternIndex];
                            allHdriSteps += 1;
                            hdriDirty = true;
                            if (allHdriSteps >= hdriPatternSequence.length) {
                                allPhase = 'olat';
                                allHdriSteps = 0;
                                args.lightstage.patterns.idx = 0;
                                args.lightstage.patterns.last_update = curr;
                            }
                        }
                    }
                    if (hdriDirty) {
                        applyHDRIPattern();
                        hdriDirty = false;
                    }
                } else {
                    _olatColor.set(args.lightstage.patterns.olatColor || 0xffffff);
                    const olatIntensity = (typeof args.lightstage.patterns.olatIntensity === 'number') ? args.lightstage.patterns.olatIntensity : 1.0;
                    const olatAutoplay = args.lightstage.patterns.autoplay === true;
                    if (olatAutoplay && args.lightstage.patterns.olatPausedApplied) {
                        args.lightstage.patterns.olatPausedApplied = false;
                    }
                    const olatInterval = 1000 / args.lightstage.patterns.fps;
                    const shouldStep = olatAutoplay
                        ? (curr - args.lightstage.patterns.last_update > olatInterval)
                        : (!args.lightstage.patterns.olatPausedApplied);

                    if (shouldStep) {
                        args.lightstage.patterns.last_update = curr;

                        let n_all_white = args.lightstage.patterns.fps;
                        let n_all_off = args.lightstage.patterns.fps / 2;

                        lightboards.children.forEach((lightboard, i) => {
                            let leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                            let leds_init = lightboard.userData['leds'].colors;
                            const isOlatBoard = (i + (n_all_white + n_all_off) == args.lightstage.patterns.idx);
                            if (!isOlatBoard) {
                                _whiteColor.setRGB(leds_init[0], leds_init[1], leds_init[2]);
                            }
                            let led_light = lightboard.getObjectByName('led_light');
                            if (args.lightstage.patterns.idx < n_all_white) {
                                for (let j = 0; j < leds.count; j++) {
                                    leds.setXYZ(j, leds_init[3*j], leds_init[3*j+1], leds_init[3*j+2]);
                                    led_light.visible = true;
                                }
                            } else if (args.lightstage.patterns.idx < (n_all_white + n_all_off)) {
                                for (let j = 0; j < leds.count; j++) {
                                    leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                    led_light.visible = false;
                                }
                            } else {
                                if (i+(n_all_white + n_all_off) == args.lightstage.patterns.idx) {
                                    for (let j = 0; j < leds.count; j++) {
                                        const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                                        if (isWhite) {
                                            leds.setXYZ(j, olatIntensity * _olatColor.r, olatIntensity * _olatColor.g, olatIntensity * _olatColor.b);
                                            led_light.visible = true;
                                        } else {
                                            leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                        }
                                    }
                                } else {
                                    for (let j = 0; j < leds.count; j++) {
                                        const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                                        if (isWhite) {
                                            leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                                            led_light.visible = false;
                                        }
                                    }
                                }
                            }
                            if (led_light) {
                                if (args.lightstage.patterns.idx >= (n_all_white + n_all_off)) {
                                    if (isOlatBoard) {
                                        led_light.color.copy(_olatColor);
                                        led_light.intensity = Math.max(0.0, olatIntensity);
                                    }
                                }
                            }
                            leds.needsUpdate = true;
                        });

                        if (olatAutoplay) {
                            const total = lightboards.children.length + (n_all_white + n_all_off);
                            const nextIdx = (args.lightstage.patterns.idx + 1) % total;
                            if (nextIdx === 0) {
                                allPhase = 'hdri';
                                hdriDirty = true;
                                hdriLastUpdate = 0;
                            }
                            args.lightstage.patterns.idx = nextIdx;
                        } else {
                            args.lightstage.patterns.olatPausedApplied = true;
                        }
                    }
                }
            } else if (args.lightstage.patterns.active == 'warmup') {
                _olatColor.set(args.lightstage.patterns.olatColor || 0xffffff);
                const olatIntensity = (typeof args.lightstage.patterns.olatIntensity === 'number') ? args.lightstage.patterns.olatIntensity : 1.0;
                const warmupChanged = (_warmupIntensity !== olatIntensity) || !_warmupColor.equals(_olatColor);
                if (args.lightstage.patterns.idx >= 0 || warmupChanged) {
                    lightboards.children.forEach((lightboard, i) => {
                        let leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                        let leds_init = lightboard.userData['leds'].colors;
                        let led_light = lightboard.getObjectByName('led_light');
                        for (let j = 0; j < leds.count; j++) {
                            const isWhite = (leds_init[3*j] === leds_init[3*j+1] && leds_init[3*j+1] === leds_init[3*j+2]);
                            if (isWhite) {
                                leds.setXYZ(j, olatIntensity * _olatColor.r, olatIntensity * _olatColor.g, olatIntensity * _olatColor.b);
                            } else {
                                leds.setXYZ(j, leds_init[3*j], leds_init[3*j+1], leds_init[3*j+2]);
                            }
                            led_light.visible = true;
                        }
                        if (led_light) {
                            led_light.color.copy(_olatColor);
                            led_light.intensity = Math.max(0.0, olatIntensity);
                        }
                        leds.needsUpdate = true;
                    });
                    _warmupColor.copy(_olatColor);
                    _warmupIntensity = olatIntensity;
                    args.lightstage.patterns.idx = -1; // set this to static, other dynamic patterns will automatically make this positive
                }
            } else if (args.lightstage.patterns.active == 'off') {
                if (args.lightstage.patterns.idx >= 0) {
                    lightboards.children.forEach((lightboard, i) => {
                        let leds = lightboard.getObjectByName('leds').geometry.attributes.customColor;
                        let leds_init = lightboard.userData['leds'].colors;
                        let led_light = lightboard.getObjectByName('led_light');
                        for (let j = 0; j < leds.count; j++) {
                            leds.setXYZ(j, off*leds_init[3*j], off*leds_init[3*j+1], off*leds_init[3*j+2]);
                            led_light.visible = false;
                        }
                        leds.needsUpdate = true;
                    });
                    args.lightstage.patterns.idx = -1; // set this to static, other dynamic patterns will automatically make this positive
                }
            }
        }

        function syncIlluminationLights() {
            if (!lightboards || !illuminationLightsGrey || !illuminationLightsChrome) return;
            if (illuminationLightsGrey.length === 0 || illuminationLightsChrome.length === 0) return;
            lightboards.children.forEach((lightboard, i) => {
                const srcLight = lightboard.getObjectByName('led_light');
                const greyLight = illuminationLightsGrey[i];
                const chromeLight = illuminationLightsChrome[i];
                if (!srcLight || !greyLight || !chromeLight) return;
                srcLight.getWorldPosition(_illuminationLightPos);
                greyLight.position.copy(_illuminationLightPos);
                chromeLight.position.copy(_illuminationLightPos);
                greyLight.visible = srcLight.visible;
                chromeLight.visible = srcLight.visible;
                greyLight.color.copy(srcLight.color);
                chromeLight.color.copy(srcLight.color);
                greyLight.power = srcLight.power;
                chromeLight.power = srcLight.power;
            });
        }

        function setupOrbitControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = args.controls.enableDamping; // Enable inertia
            controls.dampingFactor = args.controls.dampingFactor;
            controls.autoRotate = args.controls.autoRotate;
            controls.autoRotateSpeed = args.controls.autoRotateSpeed;
        }

        // Animation loop
        function animate() {
            render();
            stats.update();
            controls.update();
        }

        function render() {

            // main scene
            requestAnimationFrame(animate);
            renderer.setClearColor( 0x000000, 1 );
            renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
            renderer.render(scene, camera);
            labelRenderer.render( scene, camera );

            // updates
            if (rig) {
                rig.visible = args.lightstage.rig.show;
                rig.material.opacity = args.lightstage.rig.opacity * (1 + Math.sin(new Date().getTime() * .0025 * args.lightstage.rig.flashSpeed)); // change opacity of the rig
            }
        
            if (helper) {
                helper.visible = args.render.rayCaster.displayHelper;
            }

            // update multiple camera helpers and markers visibility/update
            if (cameraHelpersArr && cameraHelpersArr.length > 0) {
                cameraHelpersArr.forEach(h => {
                    if (h) {
                        h.visible = args.render.camera.showCamera;
                        h.update();
                    }
                });
            }
            if (cameraMarkers) {
                cameraMarkers.visible = args.render.camera.showCamera;
            }

            if (mesh && args.controls.autoRotate_mesh) {
                mesh.rotation.y += args.controls.autoRotate_mesh_speed / 10;
                mesh.updateMatrixWorld();
            }

            if (sphereInstance) {
                updateRays();
            }

            updatePattern();
            syncIlluminationLights();

            // inset scene
            // debugger;
            if (args.render.sideRender.show) {
                if (cameraInsetLabel) cameraInsetLabel.style.display = 'block';
                renderer.setClearColor( 0x000000, 2 );
                renderer.clearDepth(); // important!
                renderer.setScissorTest( true );
                renderer.setScissor( 20, 20, insetWidth, insetHeight);
                renderer.setViewport( 20, 20, insetWidth, insetHeight);
                renderer.render( scene, cameraObject );
                renderer.setScissorTest( false );
            } else if (cameraInsetLabel) {
                cameraInsetLabel.style.display = 'none';
            }

            // illumination preview inside the inset (lower-left corner)
            if (args.render.sideRender.showIllumination && illuminationCameraGrey && illuminationCameraChrome) {
                const baseCamera = (args.render.sideRender.illuminationView === 'overall') ? camera : cameraObject;
                if (baseCamera) {
                    _illuminationPos.set(0, 0, 0);
                    _illuminationDir.copy(baseCamera.position).sub(_illuminationPos);
                    if (_illuminationDir.lengthSq() < 1e-6) {
                        _illuminationDir.set(0, 0, 1);
                    } else {
                        _illuminationDir.normalize();
                    }
                    _illuminationOffset.copy(baseCamera.up).normalize().multiplyScalar(0.25);
                    _illuminationDir.add(_illuminationOffset).normalize();
                    illuminationCameraGrey.position.copy(_illuminationPos)
                        .addScaledVector(_illuminationDir, 0.6);
                    illuminationCameraChrome.position.copy(illuminationCameraGrey.position);
                    illuminationCameraGrey.lookAt(_illuminationPos);
                    illuminationCameraChrome.lookAt(_illuminationPos);
                }
                // 2:1 rectangle to fit two spheres side-by-side
                const miniHeight = Math.max(60, Math.floor(insetHeight / (args.render.sideRender.miniScalar || 4)));
                const miniWidth = Math.max(120, Math.floor(miniHeight * 2));
                const clampedWidth = Math.min(miniWidth, insetWidth);
                const clampedHeight = Math.min(miniHeight, insetHeight);
                const miniX = 20;
                const miniY = 20;
                const halfWidth = Math.max(1, Math.floor(clampedWidth / 2));
                const rightWidth = Math.max(1, clampedWidth - halfWidth);

                renderer.setScissorTest(true);
                renderer.setClearColor(0x000000, 0);
                // clear only the mini preview rect (not the full inset)
                renderer.setScissor(miniX, miniY, clampedWidth, clampedHeight);
                renderer.setViewport(miniX, miniY, clampedWidth, clampedHeight);
                renderer.clear(true, true, true);

                renderer.setScissor(miniX, miniY, halfWidth, clampedHeight);
                renderer.setViewport(miniX, miniY, halfWidth, clampedHeight);
                illuminationCameraGrey.aspect = halfWidth / clampedHeight;
                illuminationCameraGrey.updateProjectionMatrix();
                renderer.render(illuminationSceneGrey, illuminationCameraGrey);

                renderer.setScissor(miniX + halfWidth, miniY, rightWidth, clampedHeight);
                renderer.setViewport(miniX + halfWidth, miniY, rightWidth, clampedHeight);
                illuminationCameraChrome.aspect = rightWidth / clampedHeight;
                illuminationCameraChrome.updateProjectionMatrix();
                renderer.render(illuminationSceneChrome, illuminationCameraChrome);

                renderer.setScissorTest(false);
            }
        }

        function onclick_btn_reset() {
            // copy value of args_init to args recursively
            let sync = (a, b) => {
                for (let k in a) {
                    if (typeof a[k] === 'object') {
                        sync(a[k], b[k]);
                    } else {
                        a[k] = b[k];
                    }
                }
            }
            sync(args, args_init);
    
            // reset all args recursively but not the active property
            setupLightStage(true);
            setupOrbitControls();
        }

        function updateCameraInsetLabel() {
            if (!cameraInsetLabel) return;
            const insetH = (typeof insetHeight === 'number') ? insetHeight : 0;
            const bottom = 20 + insetH + 6;
            cameraInsetLabel.style.bottom = `${bottom}px`;
            cameraInsetLabel.style.display = args.render.sideRender.show ? 'block' : 'none';
        }

        function updateLabelMask() {
            if (!labelRenderer || !labelRenderer.domElement) return;
            if (!labelMaskSvg || !labelMaskFullRect || !labelMaskInsetRect) return;

            if (!args.render.sideRender.show) {
                labelRenderer.domElement.style.mask = 'none';
                labelRenderer.domElement.style.webkitMask = 'none';
                labelRenderer.domElement.style.maskImage = 'none';
                labelRenderer.domElement.style.webkitMaskImage = 'none';
                return;
            }

            const width = window.innerWidth;
            const height = window.innerHeight;
            const insetW = (typeof insetWidth === 'number') ? insetWidth : 0;
            const insetH = (typeof insetHeight === 'number') ? insetHeight : 0;
            const insetX = 20;
            const insetY = Math.max(0, height - (20 + insetH));

            labelMaskSvg.setAttribute('width', String(width));
            labelMaskSvg.setAttribute('height', String(height));
            labelMaskSvg.style.width = `${width}px`;
            labelMaskSvg.style.height = `${height}px`;

            labelMaskFullRect.setAttribute('x', '0');
            labelMaskFullRect.setAttribute('y', '0');
            labelMaskFullRect.setAttribute('width', String(width));
            labelMaskFullRect.setAttribute('height', String(height));

            labelMaskInsetRect.setAttribute('x', String(insetX));
            labelMaskInsetRect.setAttribute('y', String(insetY));
            labelMaskInsetRect.setAttribute('width', String(insetW));
            labelMaskInsetRect.setAttribute('height', String(insetH));

            labelRenderer.domElement.style.mask = 'url(#labelMask)';
            labelRenderer.domElement.style.webkitMask = 'url(#labelMask)';
            labelRenderer.domElement.style.maskImage = 'url(#labelMask)';
            labelRenderer.domElement.style.webkitMaskImage = 'url(#labelMask)';
            labelRenderer.domElement.style.maskRepeat = 'no-repeat';
            labelRenderer.domElement.style.webkitMaskRepeat = 'no-repeat';
            labelRenderer.domElement.style.maskSize = '100% 100%';
            labelRenderer.domElement.style.webkitMaskSize = '100% 100%';
        }

        function setLoadingVisible(isVisible) {
            if (!loadingLabel) return;
            loadingLabel.style.display = isVisible ? 'block' : 'none';
        }

        function onWindowResize(){
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
            labelRenderer.setSize( window.innerWidth, window.innerHeight );

            insetWidth = window.innerHeight / args.render.sideRender.insetScalar; // square
            insetHeight = window.innerHeight / args.render.sideRender.insetScalar;
            cameraObject.aspect = insetWidth / insetHeight;
            if (typeof args !== 'undefined' && args.render && args.render.camera && typeof args.render.camera.cameraFar !== 'undefined') {
                cameraObject.far = args.render.camera.cameraFar;
            }
            cameraObject.updateProjectionMatrix();

            updateCameraInsetLabel();
            updateLabelMask();
        }

        
        // Add the extension functions
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        // Global variables
        let scene, camera, cameraObject, renderer, labelRenderer, gui, stats;
        let cameraInsetLabel;
        let loadingLabel;
        let labelMaskSvg, labelMaskFullRect, labelMaskInsetRect;
        let rig, lightboards;
        let illuminationSceneGrey, illuminationSceneChrome;
        let illuminationCameraGrey, illuminationCameraChrome;
        let illuminationLightsGrey = [], illuminationLightsChrome = [];
        let chromeBall, greyBall;
        // multiple inset cameras and helpers
        let cameraHelper;
        let cameraViews = [];
        let cameraHelpersArr = [];
        let cameraMarkers = null;
        let selectedCameraIndex = 0;
        const clickRaycaster = new THREE.Raycaster();
        const clickMouse = new THREE.Vector2();
        // point that cameras should look at (object center). default origin until object loads
        let objectTarget = new THREE.Vector3(0,0,0);
        let controls;
        let mesh, helper, bvh;
        let sphereInstance, lineSegments, sphereLabels;
        let insetWidth, insetHeight;

        // reusable variables
        const _raycaster = new THREE.Raycaster();
        const _position = new THREE.Vector3();
        const _quaternion = new THREE.Quaternion();
        const _scale = new THREE.Vector3( 1, 1, 1 );
        const _matrix = new THREE.Matrix4();
        const _axis = new THREE.Vector3();
        const _illuminationDir = new THREE.Vector3();
        const _illuminationPos = new THREE.Vector3();
        const _illuminationOffset = new THREE.Vector3();
        const _illuminationLightPos = new THREE.Vector3();
        const _olatColor = new THREE.Color();
        const _whiteColor = new THREE.Color();
        const _warmupColor = new THREE.Color();
        let _warmupIntensity = -1;
        let hdriCache = null;
        let hdriDirty = true;
        let hdriBoardColors = null;
        const hdriPatternSequence = ['gradient', 'horizon', 'sunrise', 'coolSky', 'overcast', 'sunset', 'night', 'purpleDusk', 'desert'];
        let hdriLastUpdate = 0;
        let allPhase = 'hdri';
        let allHdriSteps = 0;

        let render_mode = 'points';
        const args_init = {
            render_mode: render_mode,
            lightstage: {
                radius: 1.5,
                ledDensity: 5,
                object: {
                    type: 'bunny',
                    scale: 1,
                    material: {
                        preset: 'metal',
                        brdf: {
                            baseColor: 0xffffff,
                            roughness: 0.2,
                            metalness: 1.0,
                            specularIntensity: 1.0,
                            specularColor: 0xffffff,
                            ior: 1.5,
                            transmission: 0.0,
                            thickness: 0.0,
                            attenuationColor: 0xffffff,
                            attenuationDistance: 0.0,
                            clearcoat: 0.0,
                            clearcoatRoughness: 0.0,
                            sheen: 0.0,
                            sheenColor: 0xffffff,
                            sheenRoughness: 0.5,
                            iridescence: 0.0,
                            iridescenceIOR: 1.3,
                            iridescenceThicknessMin: 100,
                            iridescenceThicknessMax: 400,
                            emissive: 0x000000,
                            emissiveIntensity: 0.0,
                        },
                    },
                },
                lightboard: {
                    show: true,
                    radiusWhiteLED: 0.05,
                    radiusScalarColorLED: 0.5, // the radius scalar * radiusWhiteLED is the radius of the hexogon of the color LED, which is fixed scalar due to equilateral triangle,
                    radiusScalarBoarder: 1.5, // the radius scalar * radiusWhiteLED is the radius of the hexogon of main board, fixed scalar due to equilateral triangle,
                    radiusScalarDaughter: 2.1, // the radius scalar * radiusWhiteLED is the radius of the hexogon of daughter board
                    radiusScalarDautherOffsetX: 0.3, // Parameterized offset distance towards normal direction
                    radiusScalarDautherOffsetY: 0.15,// Parameterized offset distance towards tangent direction
                    boundary: {
                        show: true,
                    },
                    leds: {
                        show: true,
                        radius: render_mode === 'points' ? 5 : 0.01,
                        colors: {
                            white: 0xffffff,
                            red: 0xff0000,
                            green: 0x00ff00,
                            blue: 0x0000ff,
                            amber: 0xffa500,
                        }
                    }
                },
                rig: {
                    show: false,
                    opacity: 0.25,
                    flashSpeed: 0,  // Speed of the light stage rig flashing
                },
                patterns: {
                    active: 'all',
                    idx: 0,
                    last_update: new Date().getTime(),
                    fps: 10,
                    autoplay: true,
                    olatColor: 0xffffff,
                    olatIntensity: 3.0,
                    hdriPattern: 'gradient',
                    hdriIntensity: 1.0,
                    hdriContrast: 0.3,
                    hdriResolution: 128,
                    olatPausedApplied: false,
                }
            },
            controls: {
                enableDamping: true,
                dampingFactor: 0.05,
                autoRotate: true,
                autoRotateSpeed: 0.1,
                autoRotate_mesh: true,
                autoRotate_mesh_speed: 0.01,
                reset: function() {},
                fullscreen: function() {},
            },
            render: {
                rayCaster: {
                    radiusScalar: 1, // the radius scalar * lightstage.radius is the radius rays
                    rays: {
                        count: 20,
                        sphereScale: 0.01,
                        color: 0x444444,
                        maxNum: 3000,
                    },
                    firstHitOnly: true,
                    useBVH: true,
                    displayHelper: true,
                    helperDepth: 10,
                },
                sideRender: {
                    show: true,
                    showIllumination: true,
                    insetScalar: 3,
                    miniScalar: 4,
                    illuminationView: 'selected',
                },
                camera: {
                    showCamera: true,
                    cameraFar: 2,
                    cameraCount: 2,
                    cameraDistance: 0.6,
                }
            },
            projects: {
                show: false,
                showTitle: true,
                items: [
                    // Research on Light Transport and Rendering
                    {
                        name: 'Material Authoring',
                        page: 'https://jingyangcarl.github.io/MaterialAuthoring/',
                        github: '',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: '',
                    },
                    {
                        name: 'Localized Gaussian Splatting Editing',
                        page: 'https://jingyangcarl.github.io/',
                        github: 'https://github.com/jingyangcarl/jingyangcarl.github.io/blob/master/index.html',
                        pdf: 'https://arxiv.org/pdf/2408.00083',
                        arxiv: 'https://arxiv.org/abs/2408.00083',
                        youtube: '',
                        paperswithcode: 'https://paperswithcode.com/paper/localized-gaussian-splatting-editing-with',
                        openreview: '',
                        cvf: '',
                        conf: 'WACV 2025',
                    },
                    {
                        name: 'Multiview Video Relighting',
                        page: 'https://jingyangcarl.github.io/RelightableStudio/',
                        github: '',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: 'US Patent Filing',
                    },
                    {
                        name: 'Polarized Reflectance Field',
                        page: 'https://jingyangcarl.github.io/PolarizedReflectanceField/',
                        github: '',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: '',
                    },
                    {
                        name: 'DiffPortrait3D',
                        page: 'https://freedomgu.github.io/DiffPortrait3D/',
                        github: 'https://github.com/FreedomGu/DiffPortrait3D',
                        pdf: 'https://arxiv.org/pdf/2312.13016',
                        arxiv: 'https://arxiv.org/abs/2312.13016',
                        youtube: 'https://www.youtube.com/watch?v=mI8RJ_f3Csw',
                        paperswithcode: '',
                        openreview: '',
                        cvf: 'https://openaccess.thecvf.com/content/CVPR2024/papers/Gu_DiffPortrait3D_Controllable_Diffusion_for_Zero-Shot_Portrait_View_Synthesis_CVPR_2024_paper.pdf',
                        conf: 'CVPR 2024',
                    },
                    {
                        name: 'Light Sampling Field',
                        page: 'https://jingyangcarl.github.io/LightSamplingField/',
                        github: 'https://github.com/jingyangcarl/LightSamplingField',
                        pdf: 'https://arxiv.org/pdf/2304.05472.pdf',
                        arxiv: 'https://arxiv.org/abs/2304.05472',
                        youtube: 'https://youtu.be/qpIgS11DlJE',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: 'ICLR 2023',
                    },
                    {
                        name: 'Virtual Light Stage',
                        page: 'https://jingyangcarl.github.io/',
                        github: 'https://github.com/jingyangcarl/jingyangcarl.github.io/blob/master/index.html',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: 'Demo',
                    },
                    // Research on Science of Science
                    {
                        name: 'Paper Copilot (11.75M+)',
                        page: 'https://papercopilot.com/',
                        github: 'https://github.com/papercopilot',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: '',
                    },
                    {
                        name: 'AI/ML Open Peer Review',
                        page: 'https://icml.cc/virtual/2025/poster/40116',
                        github: '',
                        pdf: 'https://openreview.net/pdf?id=gnyqRarPzW',
                        arxiv: 'https://arxiv.org/abs/2502.00874',
                        youtube: '',
                        paperswithcode: '',
                        openreview: 'https://openreview.net/forum?id=gnyqRarPzW',
                        cvf: '',
                        conf: 'ICML 2025',
                    },
                    {
                        name: 'The AI Imperative',
                        page: '',
                        github: '',
                        pdf: '',
                        arxiv: '',
                        youtube: '',
                        paperswithcode: '',
                        openreview: '',
                        cvf: '',
                        conf: '',
                    },
                ],
                papercopilot: function() {},
            }
        }
        let args = JSON.parse(JSON.stringify(args_init));
        args.controls.reset = function(){};
        args.controls.fullscreen = function(){window.open('https://jingyangcarl.github.io/');};
        args.projects.papercopilot = function(){window.open('https://papercopilot.com');};

        // Setup light stage
        init();
        setupGUI();
        // initialize info title visibility according to args
        const infoDiv = document.getElementById('info');
        if (infoDiv) infoDiv.style.display = args.projects.showTitle ? 'block' : 'none';
        setupStats();
        setupLightStage();
        loadObject(args.lightstage.object.type);
        setupRayCaster();
        setupIlluminationPreview();
        setupOrbitControls();
        updateLabelMask();
        setLoadingVisible(args.lightstage.object.type === 'bunny');

        // create multiple cameras arranged in a 'W' shape and their helpers/markers
        function createCameraViews() {
            // remove previous helpers/markers if present
            if (cameraHelpersArr.length > 0) {
                cameraHelpersArr.forEach(h => scene.remove(h));
                cameraHelpersArr = [];
            }
            if (cameraMarkers) {
                scene.remove(cameraMarkers);
                cameraMarkers = null;
            }

            cameraViews = [];
            cameraMarkers = new THREE.Group();

            // base distance: use configured cameraDistance or fallback to current cameraObject distance
            const distance = (args && args.render && args.render.camera && args.render.camera.cameraDistance) ? args.render.camera.cameraDistance : (cameraObject.position.length() || 0.6);

            // compute coordinates to form a 'W' shape distributed across two rows
            const count = args && args.render && args.render.camera && args.render.camera.cameraCount ? Math.max(1, Math.min(20, Math.round(args.render.camera.cameraCount))) : 8;
            // top row proportion (approx 5/8 of default 8 -> 5). Clamp so both rows exist when possible
            let topCount = Math.min(count - 1, Math.max(1, Math.round(count * 5 / 8)));
            if (topCount >= count) topCount = count - 1;
            const bottomCount = count - topCount;

            // Sample directions from an icosphere to get well-distributed camera positions.
            function sampleIcosphereDirections(n) {
                let subdiv = 0;
                let verts = [];
                while (verts.length < n && subdiv <= 5) {
                    const geom = new THREE.IcosahedronGeometry(1, subdiv);
                    const pos = geom.attributes.position;
                    const uniq = [];
                    const seen = new Set();
                    for (let i = 0; i < pos.count; i++) {
                        const v = new THREE.Vector3().fromBufferAttribute(pos, i).normalize();
                        const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;
                        if (!seen.has(key)) { seen.add(key); uniq.push(v); }
                    }
                    verts = uniq;
                    subdiv++;
                }
                // fallback to Fibonacci sphere if not enough verts
                if (verts.length < n) {
                    verts = [];
                    for (let i = 0; i < n; i++) {
                        const t = (i + 0.5) / n;
                        const phi = Math.acos(1 - 2 * t);
                        const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                        verts.push(new THREE.Vector3(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi)));
                    }
                }
                const sampled = [];
                const step = Math.floor(verts.length / n) || 1;
                for (let i = 0; i < n; i++) sampled.push(verts[(i * step) % verts.length]);
                return sampled;
            }

            const dirs = sampleIcosphereDirections(count);

            dirs.forEach((dir, idx) => {
                const cam = new THREE.PerspectiveCamera(
                    cameraObject.fov || 75,
                    1,
                    cameraObject.near || 0.1,
                    (idx === selectedCameraIndex) ? (args.render.camera.cameraFar || 2) : 0.001
                );

                cam.position.copy(dir.clone().multiplyScalar(distance));
                // ensure camera points to the object target (object center)
                cam.lookAt(objectTarget);
                cam.updateMatrixWorld(true);
                cam.updateProjectionMatrix();
                cameraViews.push(cam);

                // helper
                const helper = new THREE.CameraHelper(cam);
                helper.material.color.set(idx === selectedCameraIndex ? 0xffff00 : 0xffffff);
                helper.visible = args.render.camera.showCamera;
                helper.update();
                scene.add(helper);
                cameraHelpersArr.push(helper);

                // clickable marker
                const markerMat = new THREE.MeshBasicMaterial({ color: idx === selectedCameraIndex ? 0xffff00 : 0xffffff });
                const marker = new THREE.Mesh(new THREE.SphereGeometry(0.02), markerMat);
                marker.position.copy(cam.position);
                marker.userData = { idx };
                cameraMarkers.add(marker);
            });

            scene.add(cameraMarkers);
        }

        function selectCamera(idx) {
            if (idx < 0 || idx >= cameraViews.length) return;
            selectedCameraIndex = idx;
            // copy selected camera to cameraObject (inset)
            const src = cameraViews[idx];
            cameraObject.position.copy(src.position);
            cameraObject.quaternion.copy(src.quaternion);
            cameraObject.fov = src.fov;
            cameraObject.near = src.near;
            // selected camera uses the configured far; others collapse to tiny far
            cameraObject.far = args.render.camera.cameraFar;
            cameraObject.updateProjectionMatrix();

            // update helper/marker highlights
            cameraHelpersArr.forEach((h, i) => {
                h.material.color.set(i === idx ? 0xffff00 : 0xffffff);
                if (cameraViews[i]) {
                    cameraViews[i].far = (i === idx) ? args.render.camera.cameraFar : 0.001;
                    cameraViews[i].updateProjectionMatrix();
                }
            });
            cameraMarkers.children.forEach((m, i) => {
                m.material.color.set(i === idx ? 0xffff00 : 0xffffff);
            });
        }

        // click handler to pick markers
        renderer.domElement.addEventListener('pointerdown', (ev) => {
            const rect = renderer.domElement.getBoundingClientRect();
            clickMouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            clickMouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            clickRaycaster.setFromCamera(clickMouse, camera);
            const intersects = clickRaycaster.intersectObjects(cameraMarkers.children, true);
            if (intersects.length > 0) {
                const idx = intersects[0].object.userData.idx;
                selectCamera(idx);
            }
        });

        // create initial views
        createCameraViews();
        // ensure selected camera copied to inset
        selectCamera(selectedCameraIndex);

        animate();

        window.addEventListener( 'resize', onWindowResize, false );
        onWindowResize();
    </script>
</body>
</html>
